<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Atomic &mdash; Monix</title>

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:image" content="https://terdong.github.io/monix-doc-kr/public/images/monix-logo-rect.png" />
  <meta name="twitter:title" content="Atomic &mdash; Monix" />
  <meta name="twitter:description" content="References that can be updated atomically, for lock-free thread-safe programming, resembling Java's AtomicReference, but better." />

  <!-- Facebook Open-Graph -->
  <meta property="og:url" content="https://terdong.github.io/monix-doc-kr/docs/3x/execution/atomic" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Atomic &mdash; Monix" />
  <meta property="og:description" content="References that can be updated atomically, for lock-free thread-safe programming, resembling Java's AtomicReference, but better." />
  <meta property="og:image" content="https://terdong.github.io/monix-doc-kr/public/images/monix-logo.png" />

  <!-- Google authorship -->
  <link href="https://aboutme.google.com/b/114636882626291639915/" rel="publisher">

  <!-- Javascript -->
  <script src="//code.jquery.com/jquery-2.2.4.min.js" type="text/javascript" language="javascript"></script>
  <script src="/monix-doc-kr/public/js/toc.js" type="text/javascript" language="javascript"></script>
  <script src="/monix-doc-kr/public/js/init.js" type="text/javascript" language="javascript"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="/monix-doc-kr/public/css/all.css?1529916931766311100">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/monix-doc-kr/public/css/forkme.ie.css?1529916931766311100">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/monix-doc-kr/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/monix-doc-kr/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/monix-doc-kr/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/monix-doc-kr/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/monix-doc-kr/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/monix-doc-kr/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/monix-doc-kr/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/monix-doc-kr/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/monix-doc-kr/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/monix-doc-kr/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/monix-doc-kr/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/monix-doc-kr/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/monix-doc-kr/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/monix-doc-kr/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/monix-doc-kr/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/monix-doc-kr/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/monix-doc-kr/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/monix-doc-kr/">
          <img src="/monix-doc-kr/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/monix-doc-kr/">About</a>
      <a class="sidebar-nav-item" href="/monix-doc-kr/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/monix-doc-kr/docs/3x/">Documentation</a>
      <a class="sidebar-nav-item" href="/monix-doc-kr/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="https://github.com/monix/monix">GitHub project</a>
      <a class="sidebar-nav-item" href="/monix-doc-kr/social.html">Follow @Monix</a>
    </nav>
  </div>
</aside>

    
      <article class="content container">
        <div class="page">
  <h1 class="page-title">Atomic</h1>
  <nav role="navigation" id="type-info">
    <a href="/monix-doc-kr/api/3.0/monix/execution/atomic/Atomic.html">API Documentation</a>
    <a href="https://github.com/monix/monix/blob/v3.0.0-RC1/monix-execution/jvm/src/main/scala/monix/execution/atomic/Atomic.scala">Source Code</a>
    
    <a href="https://github.com/monix/monix.io/edit/master/_tut/docs/3x/execution/atomic.md">Edit Page</a>
  </nav>

  <nav role="navigation" id="toc"></nav>

  <p>Scala is awesome at handling concurrency and parallelism, providing
high-level tools for handling it, however sometimes you need to go
lower level. Java’s library provides all the multi-threading
primitives required, however the interfaces of these primitives
sometime leave something to be desired.</p>

<p>One such example are the atomic references provided in
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html">java.util.concurrent.atomic</a>
package. This project is an attempt at improving these types for daily
usage.</p>

<h2 id="providing-a-common-interface">Providing a Common interface</h2>

<p>So you have
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html">j.u.c.a.AtomicReference&lt;V&gt;</a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html">j.u.c.a.AtomicInteger</a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLong.html">j.u.c.a.AtomicLong</a>
and
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLong.html">j.u.c.a.AtomicBoolean</a>.
The reason why <code class="highlighter-rouge">AtomicReference&lt;V&gt;</code> does not suffice is because
compare-and-set works with reference equality, not structural equality
like it happens with primitives. So you cannot simply box an integer
and use it safely, plus you’ve got the whole boxing/unboxing overhead.</p>

<p>One problem is that all of these classes do not share a common
interface and there’s no reason for why they shouldn’t.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.atomic._</span>

<span class="k">val</span> <span class="n">refInt1</span><span class="k">:</span> <span class="kt">Atomic</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">refInt2</span><span class="k">:</span> <span class="kt">AtomicInt</span> <span class="o">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="k">val</span> <span class="n">refLong1</span><span class="k">:</span> <span class="kt">Atomic</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="mi">0L</span><span class="o">)</span>
<span class="k">val</span> <span class="n">refLong2</span><span class="k">:</span> <span class="kt">AtomicLong</span> <span class="o">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="mi">0L</span><span class="o">)</span>

<span class="k">val</span> <span class="n">refString1</span><span class="k">:</span> <span class="kt">Atomic</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">refString2</span><span class="k">:</span> <span class="kt">AtomicAny</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="working-with-numbers">Working with Numbers</h3>

<p>One really common use-case for atomic references are for numbers to
which you need to add or subtract. To this purpose
<code class="highlighter-rouge">j.u.c.a.AtomicInteger</code> and <code class="highlighter-rouge">j.u.c.a.AtomicLong</code> have an
<code class="highlighter-rouge">incrementAndGet</code> helper. However Ints and Longs aren’t the only types
you normally need. How about <code class="highlighter-rouge">Float</code> and <code class="highlighter-rouge">Double</code> and <code class="highlighter-rouge">Short</code>? How about
<code class="highlighter-rouge">BigDecimal</code> and <code class="highlighter-rouge">BigInt</code>?</p>

<p>In Scala, thanks to the
<a href="http://www.scala-lang.org/api/current/index.html#scala.math.Numeric">Numeric[T]</a>
type-class, we can do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
<span class="c1">// ref: monix.execution.atomic.AtomicNumberAny[scala.math.BigInt] = monix.execution.atomic.AtomicNumberAny@523b3ece
</span>
<span class="c1">// now we can increment a BigInt
</span><span class="n">ref</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">()</span>
<span class="c1">// res4: scala.math.BigInt = 2
</span>
<span class="c1">// or adding to it another value
</span><span class="n">ref</span><span class="o">.</span><span class="n">addAndGet</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="s">"329084291234234"</span><span class="o">))</span>
<span class="c1">// res6: scala.math.BigInt = 329084291234236
</span></code></pre></div></div>

<p>But then if we have a type that isn’t a number:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">string</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span>
</code></pre></div></div>

<p>Trying to apply numeric operations will of course fail:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">string</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">()</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">17</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">incrementAndGet</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">monix.execution.atomic.AtomicAny</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
       <span class="n">string</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">()</span>
              <span class="o">^</span>
</code></pre></div></div>

<h3 id="support-for-other-primitives-float-double-short-char-byte">Support for Other Primitives (Float, Double, Short, Char, Byte)</h3>

<p>Here’s a common gotcha with Java’s <code class="highlighter-rouge">AtomicReference&lt;V&gt;</code>. Suppose
we’ve got this Java atomic:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicReference</span>

<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicReference</span><span class="o">(</span><span class="mf">0.0</span><span class="o">)</span>
</code></pre></div></div>

<p>The unexpected happens on <code class="highlighter-rouge">compareAndSet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">isSuccess</span> <span class="k">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">compareAndSet</span><span class="o">(</span><span class="mf">0.0</span><span class="o">,</span> <span class="mf">100.0</span><span class="o">)</span>
<span class="c1">// isSuccess: Boolean = false
</span></code></pre></div></div>

<p>Calling <code class="highlighter-rouge">compareAndSet</code> fails because when using <code class="highlighter-rouge">AtomicReference&lt;V&gt;</code>
the equality comparison is done by reference and it doesn’t work for
primitives because the process of
<a href="http://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing/Unboxing</a>
is involved. And then there’s the efficiency issue. By using an
AtomicReference, you’ll end up with extra boxing/unboxing going on.</p>

<p><code class="highlighter-rouge">Float</code> can be stored inside an <code class="highlighter-rouge">AtomicInteger</code> by using Java’s
<code class="highlighter-rouge">Float.floatToIntBits</code> and <code class="highlighter-rouge">Float.intBitstoFloat</code>. <code class="highlighter-rouge">Double</code> can be
stored inside an <code class="highlighter-rouge">AtomicLong</code> by using Java’s
<code class="highlighter-rouge">Double.doubleToLongBits</code> and <code class="highlighter-rouge">Double.longBitsToDouble</code>. <code class="highlighter-rouge">Char</code>,
<code class="highlighter-rouge">Byte</code> and <code class="highlighter-rouge">Short</code> can be stored inside an <code class="highlighter-rouge">AtomicInteger</code> as well,
with special care to handle overflows correctly. All this is done to avoid boxing
for performance reasons.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="mf">0.0</span><span class="o">)</span>
<span class="c1">// ref: monix.execution.atomic.AtomicDouble = monix.execution.atomic.AtomicDouble@21767375
</span>
<span class="n">ref</span><span class="o">.</span><span class="n">compareAndSet</span><span class="o">(</span><span class="mf">0.0</span><span class="o">,</span> <span class="mf">100.0</span><span class="o">)</span>
<span class="c1">// res9: Boolean = true
</span>
<span class="n">ref</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">()</span>
<span class="c1">// res10: Double = 101.0
</span>
<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="sc">'a'</span><span class="o">)</span>
<span class="c1">// ref: monix.execution.atomic.AtomicChar = monix.execution.atomic.AtomicChar@59601a6d
</span>
<span class="n">ref</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">()</span>
<span class="c1">// res11: Char = b
</span>
<span class="n">ref</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">()</span>
<span class="c1">// res12: Char = c
</span></code></pre></div></div>

<h3 id="common-pattern-loops-for-transforming-the-value">Common Pattern: Loops for Transforming the Value</h3>

<p><code class="highlighter-rouge">incrementAndGet</code> represents just one use-case of a simple and more
general pattern. To push items in a queue for example, one would
normally do something like this in Java:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">collection.immutable.Queue</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicReference</span>

<span class="k">def</span> <span class="n">pushElementAndGet</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span>, <span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">T</span><span class="o">]</span>
  <span class="o">(</span><span class="n">ref</span><span class="k">:</span> <span class="kt">AtomicReference</span><span class="o">[</span><span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]],</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  
  <span class="k">var</span> <span class="n">continue</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="k">var</span> <span class="n">update</span> <span class="k">=</span> <span class="kc">null</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">continue</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">current</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
    <span class="k">var</span> <span class="n">update</span> <span class="k">=</span> <span class="n">current</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="n">continue</span> <span class="k">=</span> <span class="o">!</span><span class="n">ref</span><span class="o">.</span><span class="n">compareAndSet</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">update</span><span class="o">)</span>
  <span class="o">}</span>
  
  <span class="n">update</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is such a common pattern. Taking a page from the wonderful
<a href="https://nbronson.github.io/scala-stm/">ScalaSTM</a>,
with <code class="highlighter-rouge">Atomic</code> you can simply do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="nc">Queue</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>
<span class="c1">// ref: monix.execution.atomic.AtomicAny[scala.collection.immutable.Queue[String]] = monix.execution.atomic.AtomicAny@7fc4ef5c
</span>
<span class="c1">// Transforms the value and returns the update
</span><span class="n">ref</span><span class="o">.</span><span class="n">transformAndGet</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="s">"hello"</span><span class="o">))</span>
<span class="c1">// res15: scala.collection.immutable.Queue[String] = Queue(hello)
</span>
<span class="c1">// Transforms the value and returns the current one
</span><span class="n">ref</span><span class="o">.</span><span class="n">getAndTransform</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="s">"world"</span><span class="o">))</span>
<span class="c1">// res17: scala.collection.immutable.Queue[String] = Queue(hello)
</span>
<span class="c1">// We can be specific about what we want extracted as a result
</span><span class="n">ref</span><span class="o">.</span><span class="n">transformAndExtract</span> <span class="o">{</span> <span class="n">current</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">update</span><span class="o">)</span> <span class="k">=</span> <span class="n">current</span><span class="o">.</span><span class="n">dequeue</span>
  <span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">update</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// res19: String = hello
</span>
<span class="c1">// Or the shortcut, because it looks so good
</span><span class="n">ref</span><span class="o">.</span><span class="n">transformAndExtract</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">dequeue</span><span class="o">)</span>
<span class="c1">// res21: String = world
</span></code></pre></div></div>

<p>Voilà, you now have a concurrent, thread-safe and non-blocking
Queue. You can do this for whatever persistent data-structure you
want.</p>

<p>NOTE: the transform methods are implemented using Scala macros, so
you get zero overhead by using them.</p>

<h2 id="scalajs-support-for-targeting-javascript">Scala.js support for targeting Javascript</h2>

<p>These atomic references are also cross-compiled to <a href="http://www.scala-js.org/">Scala.js</a>
for targeting Javascript engines, because:</p>

<ul>
  <li>it’s a useful way of boxing mutable variables, in case you need to box</li>
  <li>it’s a building block for doing synchronization, so useful for code that you want cross-compiled</li>
  <li>because mutability doesn’t take <em>time</em> into account and <code class="highlighter-rouge">compareAndSet</code> does, atomic references and
<code class="highlighter-rouge">compareAndSet</code> in particular is also useful in a non-multi-threaded / asynchronous environment</li>
</ul>

<h2 id="efficiency">Efficiency</h2>

<p>Atomic references are low-level primitives for concurrency and because
of that any extra overhead is unacceptable.</p>

<h3 id="boxing--unboxing">Boxing / Unboxing</h3>

<p>Working with a common <code class="highlighter-rouge">Atomic[T]</code> interface implies boxing/unboxing of
primitives. This is why the constructor for atomic references always
returns the most specialized version, as to avoid boxing and unboxing:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="c1">// ref: monix.execution.atomic.AtomicInt = AtomicInt(1)
</span>
<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="mi">1L</span><span class="o">)</span>
<span class="c1">// ref: monix.execution.atomic.AtomicLong = AtomicLong(1)
</span>
<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="c1">// ref: monix.execution.atomic.AtomicBoolean = AtomicBoolean(true)
</span>
<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
<span class="c1">// ref: monix.execution.atomic.AtomicAny[String] = monix.execution.atomic.AtomicAny@316974a6
</span></code></pre></div></div>

<p>Increments/decrements are done by going through the
<a href="http://www.scala-lang.org/api/current/index.html#scala.math.Numeric">Numeric[T]</a>
provided implicit, but only for <code class="highlighter-rouge">AnyRef</code> types, such as <code class="highlighter-rouge">BigInt</code> and
<code class="highlighter-rouge">BigDecimal</code>. For Scala’s primitives the logic has been optimized to
bypass <code class="highlighter-rouge">Numeric[T]</code>.</p>

<h3 id="cache-padded-versions-for-avoiding-the-false-sharing-problem">Cache-padded versions for avoiding the false sharing problem</h3>

<p>In order to reduce cache contention, cache-padded versions for all Atomic
classes are provided. For reference on what that means, see:</p>

<ul>
  <li><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html">mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html</a></li>
  <li><a href="http://openjdk.java.net/jeps/142">JEP 142: Reduce Cache Contention on Specified Fields</a></li>
</ul>

<p>To use the cache-padded versions, you need to override the default
<code class="highlighter-rouge">PaddingStrategy</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.atomic.PaddingStrategy.</span><span class="o">{</span><span class="nc">Left64</span><span class="o">,</span> <span class="nc">LeftRight256</span><span class="o">}</span>

<span class="c1">// Applies padding to the left of the value for a cache line 
// of 64 bytes
</span><span class="k">val</span> <span class="n">ref1</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">.</span><span class="n">withPadding</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Left64</span><span class="o">)</span>

<span class="c1">// Applies padding both to the left and the right of the value 
// for a total object size of at least 256 bytes
</span><span class="k">val</span> <span class="n">ref2</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">.</span><span class="n">withPadding</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">LeftRight256</span><span class="o">)</span>
</code></pre></div></div>

<p>The strategies available are:</p>

<ul>
  <li><code class="highlighter-rouge">NoPadding</code>: doesn’t apply any padding, the default</li>
  <li><code class="highlighter-rouge">Left64</code>: applies padding to the left of the value, for a cache line of 64 bytes</li>
  <li><code class="highlighter-rouge">Right64</code>: applies padding to the right of the value, for a cache line of 64 bytes</li>
  <li><code class="highlighter-rouge">LeftRight128</code>: applies padding to both the left and the right, for a cache line of 128 bytes</li>
  <li><code class="highlighter-rouge">Left128</code>: applies padding to the left of the value, for a cache line of 128 bytes</li>
  <li><code class="highlighter-rouge">Right128</code>: applies padding to the right of the value, for a cache line of 128 bytes</li>
  <li><code class="highlighter-rouge">LeftRight256</code>: applies padding to both the left and the right, for a cache line of 256 bytes</li>
</ul>

<p>And now you can join the folks that have mechanical sympathy :-P</p>

<h2 id="platform-intrinsics">Platform Intrinsics</h2>

<p>Java 8 came with platform intrinsics, such that:</p>

<ol>
  <li>Issue
<a href="https://bugs.openjdk.java.net/browse/JDK-7023898">JDK-7023898</a>
changed the <code class="highlighter-rouge">getAndAdd</code> method in <code class="highlighter-rouge">Unsafe</code> and all related methods
in the <code class="highlighter-rouge">AtomicInt</code> and <code class="highlighter-rouge">AtomicLong</code> implementations, like
<code class="highlighter-rouge">getAndIncrement</code> and <code class="highlighter-rouge">incrementAndGet</code>, to be translated to 
<code class="highlighter-rouge">LOCK XADD</code> instructions on x86/x64 platforms, being far cheaper than 
CAS loops based on <code class="highlighter-rouge">LOCK CMPXCHG</code> (normal <code class="highlighter-rouge">compareAndSet</code>)</li>
  <li>Issue
<a href="https://bugs.openjdk.java.net/browse/JDK-8004330">JDK-8004330</a>
changed the <code class="highlighter-rouge">getAndSet</code> in <code class="highlighter-rouge">Unsafe</code> and all atomic implementations
to be translated to <code class="highlighter-rouge">LOCK XCHG</code>, which is also cheaper than CAS
loops based on <code class="highlighter-rouge">LOCK CMPXCHG</code> (normal <code class="highlighter-rouge">compareAndSet</code>).  See
this
<a href="https://blogs.oracle.com/dave/entry/atomic_fetch_and_add_vs">article by Dave Dice</a>
for why this is awesome</li>
</ol>

<p>Monix’s <code class="highlighter-rouge">Atomic</code> implementations are also using the same platform
intrinsics when running on top of Java 8, but automatically fallback
to normal <code class="highlighter-rouge">compareAndSet</code> loops if running on top of Java 6 or 7.</p>

<p>So when you do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">numberRef</span> <span class="k">=</span> <span class="nc">Atomic</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="c1">// numberRef: monix.execution.atomic.AtomicInt = AtomicInt(0)
</span>
<span class="k">val</span> <span class="n">previous</span> <span class="k">=</span> <span class="n">numberRef</span><span class="o">.</span><span class="n">getAndSet</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="c1">// previous: Int = 0
</span>
<span class="k">val</span> <span class="n">current</span> <span class="k">=</span> <span class="n">numberRef</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">()</span>
<span class="c1">// current: Int = 2
</span></code></pre></div></div>

<p>This code, depending on the Java version used will either use
optimized CPU instructions (Java 8 and above) or fallback to CAS
loops (e.g. Java 6 and 7, Android).</p>


  <div id="version3x">
    You are viewing the documentation for the latest Monix 3.x series.<br/>
    If you're looking for the older 2.x
    <a href="/monix-doc-kr/docs/2x/">click here</a>!
  </div>

  <div class="buttons">
    <a href="/docs/3x/">Contents</a> •
    <a href="https://github.com/monix/monix.io/edit/master/_tut/docs/3x/execution/atomic.md">
      Edit Page</a> •
    
    <a href="https://gitter.im/monix/monix">
      Join Chat</a> •
    <a href="/monix-doc-kr/social.html">
      Follow</a>
  </div>
</div>

      </article>    
    </div>

    <script>
        ((window.gitter = {}).chat = {}).options = {
          room: 'monix/monix'
        };
    </script>
    <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
  </body>
</html>
