<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Cancelable &mdash; Monix</title>

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:image" content="https://monix.io/public/images/monix-logo-rect.png" />
  <meta name="twitter:title" content="Cancelable &mdash; Monix" />
  <meta name="twitter:description" content="A one-time idempotent action that can be used to cancel async computations, or to release resources that active data-sources are holding." />

  <!-- Facebook Open-Graph -->
  <meta property="og:url" content="https://monix.io/docs/3x/execution/cancelable" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Cancelable &mdash; Monix" />
  <meta property="og:description" content="A one-time idempotent action that can be used to cancel async computations, or to release resources that active data-sources are holding." />
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />

  <!-- Google authorship -->
  <link href="https://aboutme.google.com/b/114636882626291639915/" rel="publisher">

  <!-- Javascript -->
  <script src="//code.jquery.com/jquery-2.2.4.min.js" type="text/javascript" language="javascript"></script>
  <script src="/public/js/toc.js" type="text/javascript" language="javascript"></script>
  <script src="/public/js/init.js" type="text/javascript" language="javascript"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1529908615533268600">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1529908615533268600">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/3x/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="https://github.com/monix/monix">GitHub project</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
    </nav>
  </div>
</aside>

    
      <article class="content container">
        <div class="page">
  <h1 class="page-title">Cancelable</h1>
  <nav role="navigation" id="type-info">
    <a href="/api/3.0/monix/execution/Cancelable.html">API Documentation</a>
    <a href="https://github.com/monix/monix/blob/v3.0.0-RC1/monix-execution/shared/src/main/scala/monix/execution/Cancelable.scala">Source Code</a>
    
    <a href="https://github.com/monix/monix.io/edit/master/_tut/docs/3x/execution/cancelable.md">Edit Page</a>
  </nav>

  <nav role="navigation" id="toc"></nav>

  <p>A one-time idempotent action that can be used to cancel async
computations, or to release resources that active data-sources are
holding, it is the equivalent of <code class="highlighter-rouge">java.io.Closable</code>, but without the
I/O focus, or to <code class="highlighter-rouge">IDisposable</code> from .NET, or to
<code class="highlighter-rouge">akka.actor.Cancellable</code> (but with an <code class="highlighter-rouge">l</code> dropped :)).</p>

<h2 id="base-cancelable">Base Cancelable</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">monix.execution</span>

<span class="k">trait</span> <span class="nc">Cancelable</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cancel</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The contract for well-behaved <code class="highlighter-rouge">Cancelable</code> instances:</p>

<ol>
  <li><code class="highlighter-rouge">cancel</code> is idempotent, calling it multiple times has
the same effect as calling it once</li>
  <li><code class="highlighter-rouge">cancel</code> is thread-safe, otherwise you cannot guarantee
idempotency</li>
</ol>

<p>In order to quickly build <code class="highlighter-rouge">Cancelable</code> instances:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Cancelable</span>

<span class="c1">// A cancelable that doesn't do anything on cancel
</span><span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">.</span><span class="n">empty</span>

<span class="c1">// Same thing, a cancelable that doesn't do anything
</span><span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">()</span>

<span class="c1">// Specify a callback to be called on cancel
</span><span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled!"</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="booleancancelable">BooleanCancelable</h2>

<p>The <code class="highlighter-rouge">BooleanCancelable</code> represents a cancelable that can be queried
for its canceled status, adding the necessary <code class="highlighter-rouge">isCanceled</code> query for
when we need it.</p>

<p>See the
<a href="/api/3.0/monix/execution/cancelables/BooleanCancelable.html">API Documentation</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">monix.execution.cancelables</span>

<span class="k">trait</span> <span class="nc">BooleanCancelable</span> <span class="k">extends</span> <span class="nc">Cancelable</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">isCanceled</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To have a reusable (immutable) <code class="highlighter-rouge">BooleanCancelable</code> instance thatâ€™s
already canceled:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.cancelables._</span>

<span class="c1">// Building an instance that's already canceled
</span><span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">BooleanCancelable</span><span class="o">.</span><span class="n">alreadyCanceled</span>

<span class="c1">// Doesn't do anything
</span><span class="n">c</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>

<span class="c1">// Always returns true
</span><span class="n">c</span><span class="o">.</span><span class="n">isCanceled</span>
</code></pre></div></div>

<p>To build an instance without a callback, but that can be
used to check for <code class="highlighter-rouge">isCanceled</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">BooleanCancelable</span><span class="o">()</span>
<span class="c1">// c: monix.execution.cancelables.BooleanCancelable = monix.execution.cancelables.BooleanCancelable$$anon$3@590e131
</span>
<span class="n">c</span><span class="o">.</span><span class="n">isCanceled</span>
<span class="c1">// res8: Boolean = false
</span>
<span class="n">c</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>

<span class="n">c</span><span class="o">.</span><span class="n">isCanceled</span>
<span class="c1">// res10: Boolean = true
</span></code></pre></div></div>

<p>To build an instance out of a callback that behaves like
youâ€™d expect it to:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">BooleanCancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect!"</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="compositecancelable">CompositeCancelable</h2>

<p>The <code class="highlighter-rouge">CompositeCancelable</code> is an aggregate of cancelable
references (to which you can add new references or remove existing ones)
and that are handled in aggregate when doing a <code class="highlighter-rouge">cancel()</code>.</p>

<p>See the
<a href="/api/3.0/monix/execution/cancelables/CompositeCancelable.html">API Documentation</a>.</p>

<p>The contract for <code class="highlighter-rouge">CompositeCancelable</code>:</p>

<ul>
  <li>adding and removing cancelables from the composite
is thread-safe</li>
  <li>if the composite was already canceled, then adding new
references to it will trigger their cancelation</li>
  <li>upon cancelation all references are released</li>
</ul>

<p>Usage:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Cancelable</span>

<span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">CompositeCancelable</span><span class="o">()</span>

<span class="n">c</span> <span class="o">+=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #1"</span><span class="o">))</span>
<span class="n">c</span> <span class="o">+=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #2"</span><span class="o">))</span>
<span class="n">c</span> <span class="o">+=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #3"</span><span class="o">))</span>

<span class="c1">// Cancelling will trigger all 3 of them
</span><span class="n">c</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>

<span class="c1">// Appending a new cancelable to it after cancel
// will trigger its cancelation immediately
</span><span class="n">c</span> <span class="o">+=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #4"</span><span class="o">))</span>
<span class="c1">// =&gt; Canceled #4
</span></code></pre></div></div>

<p>We can add cancelables references to our composite, but
we can also remove them, maybe because they are no longer
relevant, for GC purposes, etc:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">composite</span> <span class="k">=</span> <span class="nc">CompositeCancelable</span><span class="o">()</span>

<span class="k">val</span> <span class="n">c1</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #1"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">c2</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #2"</span><span class="o">))</span>

<span class="n">composite</span> <span class="o">+=</span> <span class="n">c1</span>
<span class="n">composite</span> <span class="o">+=</span> <span class="n">c2</span>

<span class="c1">// Removing from our composite
</span><span class="n">composite</span> <span class="o">-=</span> <span class="n">c1</span>

<span class="c1">// Canceling will now only cancel c2
</span><span class="n">composite</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
<span class="c1">// =&gt; Canceled #2
</span></code></pre></div></div>

<h2 id="multiassignmentcancelable">MultiAssignmentCancelable</h2>

<p>The <code class="highlighter-rouge">MultiAssignmentCancelable</code> is a cancelable that behaves like a
variable, referencing another cancelable reference that can be
swapped as needed.</p>

<p>See the
<a href="/api/3.0/monix/execution/cancelables/MultiAssignmentCancelable.html">API Documentation</a>.</p>

<p>Contract:</p>

<ul>
  <li>assignment is thread-safe</li>
  <li>cancelation will trigger the cancelation of the underlying
cancelable and releasing it in order to be free for GC</li>
  <li>if our assignable cancelable was canceled, then upon
subsequent assignments, the references will be canceled
immediately</li>
</ul>

<p>Usage:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">multiAssignment</span> <span class="k">=</span> <span class="nc">MultiAssignmentCancelable</span><span class="o">()</span>

<span class="k">val</span> <span class="n">c1</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #1"</span><span class="o">))</span>
<span class="n">multiAssignment</span> <span class="o">:=</span> <span class="n">c1</span>

<span class="k">val</span> <span class="n">c2</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #2"</span><span class="o">))</span>
<span class="n">multiAssignment</span> <span class="o">:=</span> <span class="n">c2</span>

<span class="c1">// Canceling it will only cancel the last assignee
</span><span class="n">multiAssignment</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
<span class="c1">// =&gt; Cancelled #2
</span>
<span class="c1">// Subsequent assignments are canceled immediately
</span><span class="k">val</span> <span class="n">c3</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #3"</span><span class="o">))</span>
<span class="n">multiAssignment</span> <span class="o">:=</span> <span class="n">c3</span>
<span class="c1">// =&gt; Canceled #3
</span></code></pre></div></div>

<p>In a multi-threading environment sometimes we cannot guarantee an
ordering on assignment and obviously ordering is important.  Thereâ€™s a
second assignment operation that takes an <code class="highlighter-rouge">order</code> numeric argument and
in case the update was made with an <code class="highlighter-rouge">order</code> thatâ€™s strictly bigger
than the current one youâ€™re trying to make, then the assignment gets
ignored, so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let's simulate a race condition
</span><span class="k">import</span> <span class="nn">monix.execution.Scheduler.</span><span class="o">{</span><span class="n">global</span> <span class="k">=&gt;</span> <span class="n">scheduler</span><span class="o">}</span>

<span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">MultiAssignmentCancelable</span><span class="o">()</span>

<span class="n">scheduler</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">c</span><span class="o">.</span><span class="n">orderedUpdate</span><span class="o">(</span>
      <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Number #2"</span><span class="o">)),</span>
      <span class="n">order</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">})</span>

<span class="n">c</span><span class="o">.</span><span class="n">orderedUpdate</span><span class="o">(</span>
  <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Number #1"</span><span class="o">)),</span>
  <span class="n">order</span> <span class="k">=</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>In the example above, there is no happens-before relationship between
the two <code class="highlighter-rouge">orderedUpdate</code> attempts, so we have non-determinism, because
a parallel thread might be faster than our current one and trigger the
number 2 update before number 1. But this will leave us with a result
that we might not want, because then the last update would be
number 1.  So here is where <code class="highlighter-rouge">orderedUpdate</code> comes in handy. We
explicitly specify an <code class="highlighter-rouge">order</code> argument and thus force an ordering to
it.</p>

<p>The example above is obvious, right? But the following one isnâ€™t and
itâ€™s in fact a pretty common pattern. Letâ€™s build a function that
executes things with a delay, tasks that can be canceled. To
add a delay, weâ€™d use a <code class="highlighter-rouge">Scheduler</code> and we want to return
a <code class="highlighter-rouge">Cancelable</code> that can cancel either the delay or the result
of our passed function argument, like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// INCORRECT EXAMPLE
</span><span class="k">import</span> <span class="nn">concurrent.duration._</span>
<span class="k">import</span> <span class="nn">monix.execution._</span>

<span class="k">def</span> <span class="n">delayedExecution</span><span class="o">(</span><span class="n">cb</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="nc">Cancelable</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">MultiAssignmentCancelable</span><span class="o">()</span>

  <span class="n">ref</span> <span class="o">:=</span> <span class="n">s</span><span class="o">.</span><span class="n">scheduleOnce</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ref</span> <span class="o">:=</span> <span class="n">cb</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="n">ref</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You may not notice it, but this is a race condition that can
yield non-deterministic behavior. Lets say the garbage collector
has problems and freezes the whole process for 5 whole seconds.
This can mean that <code class="highlighter-rouge">ref := cb()</code> might execute before the result
of <code class="highlighter-rouge">s.scheduleOnce</code> returns, as the call to <code class="highlighter-rouge">:=</code> does not have
a happens-before relationship with the actual delayed scheduling.
Which means the cancelable returned by our function will be incorrect.</p>

<p>Lets fix it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">concurrent.duration._</span>
<span class="k">import</span> <span class="nn">monix.execution._</span>

<span class="k">def</span> <span class="n">delayedExecution</span><span class="o">(</span><span class="n">cb</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="nc">Cancelable</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">MultiAssignmentCancelable</span><span class="o">()</span>
  <span class="k">val</span> <span class="n">delay</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">scheduleOnce</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ref</span><span class="o">.</span><span class="n">orderedUpdate</span><span class="o">(</span><span class="n">cb</span><span class="o">(),</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// This should be the first update, but
</span>  <span class="c1">// if not, then it is ignored!
</span>  <span class="n">ref</span><span class="o">.</span><span class="n">orderedUpdate</span><span class="o">(</span><span class="n">delay</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="n">ref</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="singleassignmentcancelable">SingleAssignmentCancelable</h2>

<p>The <code class="highlighter-rouge">SingleAssignmentCancelable</code> is similar to the
<code class="highlighter-rouge">MultiAssignmentCancelable</code>, except that it can be assigned once and
only once.</p>

<p>See the
<a href="/api/3.0/monix/execution/cancelables/SingleAssignmentCancelable.html">API Documentation</a>.</p>

<p>The contract:</p>

<ul>
  <li>it is thread-safe</li>
  <li>if canceled after assignment, the underlying cancelable gets
canceled and the reference released for GC purposes</li>
  <li>if canceled while empty, then the assigned cancelable will be
canceled immediately on assignment</li>
  <li>if assignment happens a second time, then the operation
will throw an <code class="highlighter-rouge">IllegalStateException</code>, so donâ€™t do that</li>
</ul>

<p>It is useful in cases you need a forward reference, like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">SingleAssignmentCancelable</span><span class="o">()</span>

<span class="n">ref</span> <span class="o">:=</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">scheduleAtFixedRate</span><span class="o">(</span><span class="mf">0.</span><span class="n">seconds</span><span class="o">,</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// This wouldn't be correct without having an already
</span>  <span class="c1">// initialized value, as it would be a forward reference
</span>  <span class="c1">// (e.g. a reference used before it's initialized), which
</span>  <span class="c1">// could lead to a NullPointerException, not cool!
</span>  <span class="n">ref</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It is also possible to specify at construction time an extra
cancelable reference to cancel, in addition to the assigned reference:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">guest</span> <span class="k">=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"extra canceled"</span><span class="o">))</span>
  <span class="nc">SingleAssignmentCancelable</span><span class="o">.</span><span class="n">plusOne</span><span class="o">(</span><span class="n">guest</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">c</span> <span class="o">:=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"primary canceled"</span><span class="o">))</span>

<span class="n">c</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
<span class="c1">//=&gt; extra canceled
//=&gt; primary canceled
</span></code></pre></div></div>

<p>You can use <code class="highlighter-rouge">MultiAssignmentCancelable</code> for the same purpose of
course, but the implementation of <code class="highlighter-rouge">SingleAssignmentCancelable</code> is more
efficient (e.g. using <code class="highlighter-rouge">getAndSet</code>, cheaper than <code class="highlighter-rouge">compareAndSet</code>) and
the <code class="highlighter-rouge">IllegalStateException</code> is nice when dealing with concurrent code
that isnâ€™t doing what itâ€™s supposed to do.</p>

<h2 id="serialcancelable">SerialCancelable</h2>

<p>The <code class="highlighter-rouge">SerialCancelable</code> is also similar to <code class="highlighter-rouge">MultiAssignmentCancelable</code>,
being a cancelable whose underlying reference can be swapped by another
cancelable, causing the previous cancelable to be canceled on assignment.</p>

<p>See the
<a href="/api/3.0/monix/execution/cancelables/SerialCancelable.html">API Documentation</a>.</p>

<p>Contract:</p>

<ul>
  <li>assignment is thread-safe</li>
  <li>cancelation will trigger the cancelation of the underlying
cancelable and releasing it in order to be free for GC</li>
  <li>if our assignable cancelable was canceled, then upon
subsequent assignments, the references will be canceled
immediately</li>
  <li>an assignment of a new cancelable will cause the previously
stored cancelable to be canceled</li>
</ul>

<p>Usage:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">SerialCancelable</span><span class="o">()</span>

<span class="n">ref</span> <span class="o">:=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #1"</span><span class="o">))</span>

<span class="c1">// Will cancel the previous one
</span><span class="n">ref</span> <span class="o">:=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #2"</span><span class="o">))</span>
<span class="c1">// =&gt; Canceled #1
</span>
<span class="c1">// Will cancel the previous one
</span><span class="n">ref</span> <span class="o">:=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #3"</span><span class="o">))</span>
<span class="c1">// =&gt; Canceled #2
</span>
<span class="c1">// Will cancel the current one
</span><span class="n">ref</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
<span class="c1">// =&gt; Canceled #3
</span>
<span class="c1">// Afterwards everything gets canceled on assignment
</span><span class="n">ref</span> <span class="o">:=</span> <span class="nc">Cancelable</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"Canceled #4"</span><span class="o">))</span>
<span class="c1">// =&gt; Canceled #4
</span></code></pre></div></div>

<h2 id="refcountcancelable">RefCountCancelable</h2>

<p>Represents a <code class="highlighter-rouge">Cancelable</code> that can create dependent cancelable objects
and that only executes the canceling logic when all dependent
cancelable objects have been canceled.</p>

<p>Contract:</p>

<ul>
  <li>thread-safe</li>
  <li>if we create a total number of <code class="highlighter-rouge">N</code> children cancelables with
<code class="highlighter-rouge">acquire()</code>, in order for cancelation to occur we need to cancel all
<code class="highlighter-rouge">N</code> cancelables, in addition to triggering a cancelation on the
parent</li>
  <li>the ordering of cancelation doesnâ€™t matter (e.g. parent first,
children next, or vice-versa)</li>
  <li>on creating cancelables with <code class="highlighter-rouge">acquire()</code>, if our parent is already
canceled, then the returned reference will be a <code class="highlighter-rouge">Cancelable.empty</code></li>
</ul>

<p>Sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">refs</span> <span class="k">=</span> <span class="nc">RefCountCancelable</span> <span class="o">{</span> <span class="o">()</span> <span class="k">=&gt;</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Everything was canceled"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// acquiring two cancelable references
</span><span class="k">val</span> <span class="n">ref1</span> <span class="k">=</span> <span class="n">refs</span><span class="o">.</span><span class="n">acquire</span><span class="o">()</span>
<span class="k">val</span> <span class="n">ref2</span> <span class="k">=</span> <span class="n">refs</span><span class="o">.</span><span class="n">acquire</span><span class="o">()</span>

<span class="c1">// Starting the cancelation process
</span><span class="n">refs</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>

<span class="c1">// This is now true, but the callback hasn't been invoked yet
</span><span class="n">refs</span><span class="o">.</span><span class="n">isCanceled</span>
<span class="c1">// res: Boolean = true
</span>
<span class="c1">// After our RefCountCancelable was canceled, this will return
// a Cancelable.empty
</span><span class="k">val</span> <span class="n">ref3</span> <span class="k">=</span> <span class="n">refs</span><span class="o">.</span><span class="n">acquire</span><span class="o">()</span>

<span class="n">ref3</span> <span class="o">==</span> <span class="nc">Cancelable</span><span class="o">.</span><span class="n">empty</span>
<span class="c1">// res: Boolean = true
</span>
<span class="c1">// Release reference 1, nothing happens here
</span><span class="n">ref1</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>

<span class="c1">// Release reference 2, now we can execute
</span><span class="n">ref2</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
<span class="c1">// =&gt; Everything was canceled
</span></code></pre></div></div>

<p>This cancelable type is actually used in <code class="highlighter-rouge">Observable.merge</code> (â€¢â€¿â€¢)</p>


  <div id="version3x">
    You are viewing the documentation for the latest Monix 3.x series.<br/>
    If you're looking for the older 2.x
    <a href="/docs/2x/">click here</a>!
  </div>

  <div class="buttons">
    <a href="/docs/3x/">Contents</a> â€¢
    <a href="https://github.com/monix/monix.io/edit/master/_tut/docs/3x/execution/cancelable.md">
      Edit Page</a> â€¢
    
    <a href="https://gitter.im/monix/monix">
      Join Chat</a> â€¢
    <a href="/social.html">
      Follow</a>
  </div>
</div>

      </article>    
    </div>

    <script>
        ((window.gitter = {}).chat = {}).options = {
          room: 'monix/monix'
        };
    </script>
    <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
  </body>
</html>
