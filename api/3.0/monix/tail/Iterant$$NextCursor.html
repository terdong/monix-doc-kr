<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>Monix 3.0.0-RC1 - monix.tail.Iterant.NextCursor</title>
          <meta name="description" content="Monix 3.0.0 - RC1 - monix.tail.Iterant.NextCursor" />
          <meta name="keywords" content="Monix 3.0.0 RC1 monix.tail.Iterant.NextCursor" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../lib/index.js"></script>
      <script type="text/javascript" src="../../index.js"></script>
      <script type="text/javascript" src="../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">Monix<span id="doc-version">3.0.0-RC1</span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">root</span></a>
      </span>
      
      <p class="shortcomment cmt"><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><div class="fullcomment"><div class="comment cmt"><p><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><p>This is the API documentation for the <a href="https://monix.io" target="_blank">Monix</a> library.</p><h4>Package Overview</h4><p><b><a href="../execution/index.html" class="extype" name="monix.execution">monix.execution</a></b> exposes lower level primitives for dealing
with asynchronous execution:</p><ul><li><a href="../execution/atomic/index.html" class="extype" name="monix.execution.atomic">monix.execution.atomic</a> exposes the <code>Atomic</code> types, as alternative
   to <code>java.util.concurrent.atomic</code></li><li><a href="../execution/cancelables/index.html" class="extype" name="monix.execution.cancelables">monix.execution.cancelables</a> contains several
   useful <a href="../execution/Cancelable.html" class="extype" name="monix.execution.Cancelable">Cancelable</a> implementations</li><li><a href="../execution/schedulers/index.html" class="extype" name="monix.execution.schedulers">monix.execution.schedulers</a> contains several
   useful <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a> implementations</li><li><a href="../execution/rstreams/index.html" class="extype" name="monix.execution.rstreams">monix.execution.rstreams</a> contains helpers for dealing
   with the <a href="http://www.reactive-streams.org" target="_blank">Reactive Streams</a> specification</li><li><a href="../execution/misc/index.html" class="extype" name="monix.execution.misc">monix.execution.misc</a> provides miscellaneous primitives
   useful for dealing with concurrency</li><li><a href="../execution/exceptions/index.html" class="extype" name="monix.execution.exceptions">monix.execution.exceptions</a> groups some exceptions thrown by
   the implementation</li></ul><p><b><a href="../eval/index.html" class="extype" name="monix.eval">monix.eval</a></b> is for dealing with evaluation of results, thus exposing
<a href="../eval/Task.html" class="extype" name="monix.eval.Task">Task</a> and <a href="../eval/Coeval.html" class="extype" name="monix.eval.Coeval">Coeval</a>.</p><p><b><a href="../reactive/index.html" class="extype" name="monix.reactive">monix.reactive</a></b> exposes the <code>Observable</code> pattern:</p><ul><li><a href="../reactive/observables/index.html" class="extype" name="monix.reactive.observables">monix.reactive.observables</a> groups reusable <code>Observable</code> implementations</li><li><a href="../reactive/observers/index.html" class="extype" name="monix.reactive.observers">monix.reactive.observers</a> groups reusable <a href="../reactive/Observer.html" class="extype" name="monix.reactive.Observer">Observer</a>
   implementations</li><li><a href="../reactive/subjects/index.html" class="extype" name="monix.reactive.subjects">monix.reactive.subjects</a> exposes <a href="../reactive/subjects/Subject.html" class="extype" name="monix.reactive.subjects.Subject">Subject</a>
   and <a href="../reactive/subjects/ConcurrentSubject.html" class="extype" name="monix.reactive.subjects.ConcurrentSubject">ConcurrentSubject</a>,
   which are implementations of hot observables that function both as input and output</li></ul></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.monix" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="monix"></a><a id="monix:monix"></a>
      <span class="permalink">
      <a href="index.html#monix" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">monix</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="monix.tail" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tail"></a><a id="tail:tail"></a>
      <span class="permalink">
      <a href="../monix/index.html#tail" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">tail</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="monix">monix</a></dd></dl></div>
    </li><li name="monix.tail.Iterant" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Iterant"></a><a id="Iterant:Iterant"></a>
      <span class="permalink">
      <a href="../../monix/tail/index.html#Iterant" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Defines the standard Iterant builders." href="Iterant$.html"><span class="name">Iterant</span></a><span class="result"> extends <span class="extype" name="monix.tail.IterantInstances">IterantInstances</span> with <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      
      <p class="shortcomment cmt">Defines the standard <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a> builders.</p><div class="fullcomment"><div class="comment cmt"><p>Defines the standard <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a> builders.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="monix.tail">tail</a></dd></dl></div>
    </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="Iterant$$CatsAsyncInstances.html" title="Provides the cats.effect.Async instance for Iterant."></a>
                        <a href="Iterant$$CatsAsyncInstances.html" title="Provides the cats.effect.Async instance for Iterant.">CatsAsyncInstances</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="Iterant$$CatsSyncInstances.html" title="Provides the cats.effect.Sync instance for Iterant."></a>
                        <a href="Iterant$$CatsSyncInstances.html" title="Provides the cats.effect.Sync instance for Iterant.">CatsSyncInstances</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="Iterant$$Halt.html" title="The Halt state of the Iterant represents the completion state of a stream, with an optional exception if an error happened."></a>
                        <a href="Iterant$$Halt.html" title="The Halt state of the Iterant represents the completion state of a stream, with an optional exception if an error happened.">Halt</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="Iterant$$Last.html" title="The Last state of the Iterant represents a completion state as an alternative to Halt(None), describing one last element."></a>
                        <a href="Iterant$$Last.html" title="The Last state of the Iterant represents a completion state as an alternative to Halt(None), describing one last element.">Last</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="Iterant$$Next.html" title="The Next state of the Iterant represents a head / rest cons pair, where the head is a strict value."></a>
                        <a href="Iterant$$Next.html" title="The Next state of the Iterant represents a head / rest cons pair, where the head is a strict value.">Next</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="Iterant$$NextBatch.html" title="The NextBatch state of the Iterant represents an batch / rest cons pair, where batch is an Iterable type that can generate a whole batch of elements."></a>
                        <a href="Iterant$$NextBatch.html" title="The NextBatch state of the Iterant represents an batch / rest cons pair, where batch is an Iterable type that can generate a whole batch of elements.">NextBatch</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="" title="The NextCursor state of the Iterant represents an batch / rest cons pair, where batch is an Iterator type that can generate a whole batch of elements."></a>
                        <a href="" title="The NextCursor state of the Iterant represents an batch / rest cons pair, where batch is an Iterator type that can generate a whole batch of elements.">NextCursor</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="Iterant$$Suspend.html" title="Builds a stream state equivalent with Iterant.NextCursor."></a>
                        <a href="Iterant$$Suspend.html" title="Builds a stream state equivalent with Iterant.NextCursor.">Suspend</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="class type">
      <div id="definition">
        <div class="big-circle class">c</div>
        <p id="owner"><a href="../index.html" class="extype" name="monix">monix</a>.<a href="index.html" class="extype" name="monix.tail">tail</a>.<a href="Iterant$.html" class="extype" name="monix.tail.Iterant">Iterant</a></p>
        <h1>NextCursor<span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span class="name">NextCursor</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="params">(<span name="cursor">cursor: <a href="batches/BatchCursor.html" class="extype" name="monix.tail.batches.BatchCursor">BatchCursor</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>, <span name="rest">rest: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>, <span name="stop">stop: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>)</span><span class="result"> extends <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>] with <a href="http://www.scala-lang.org/api/2.12.4/scala/Product.html#scala.Product" class="extype" name="scala.Product">Product</a> with <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>The <a href="" class="extype" name="monix.tail.Iterant.NextCursor">NextCursor</a> state
        of the <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a> represents an <code>batch</code> / <code>rest</code> cons pair,
        where <code>batch</code> is an <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/Iterator.html" class="extype" name="scala.collection.Iterator">Iterator</a>
        type that can generate a whole batch of elements.</p><p>        Useful for doing buffering, or by giving it an empty iterator,
        useful to postpone the evaluation of the next element.</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>is an <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/Iterator.html" class="extype" name="scala.collection.Iterator">Iterator</a> type
        that can generate elements by traversing a collection, a standard
        array or any <code>Iterator</code></p></dd><dt class="param">rest</dt><dd class="cmt"><p>is the next state in the sequence that
        will produce the rest of the stream when evaluated</p></dd><dt class="param">stop</dt><dd class="cmt"><p>is a computation to be executed in case
        streaming is stopped prematurely, giving it a chance
        to do resource cleanup (e.g. close file handles)</p></dd></dl><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/monix/monix/tree/v3.0.0-RC1/monix-tail/shared/src/main/scala/monix/tail/Iterant.scala" target="_blank">Iterant.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>], <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a>, <span class="extype" name="java.io.Serializable">Serializable</span>, <a href="http://www.scala-lang.org/api/2.12.4/scala/Product.html#scala.Product" class="extype" name="scala.Product">Product</a>, <a href="http://www.scala-lang.org/api/2.12.4/scala/Equals.html#scala.Equals" class="extype" name="scala.Equals">Equals</a>, <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a>, <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="monix.tail.Iterant.NextCursor"><span>NextCursor</span></li><li class="in" name="monix.tail.Iterant"><span>Iterant</span></li><li class="in" name="scala.Serializable"><span>Serializable</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.Product"><span>Product</span></li><li class="in" name="scala.Equals"><span>Equals</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="monix.tail.Iterant.NextCursor#&lt;init&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(cursor:monix.tail.batches.BatchCursor[A],rest:F[monix.tail.Iterant[F,A]],stop:F[Unit]):monix.tail.Iterant.NextCursor[F,A]"></a><a id="&lt;init&gt;:NextCursor[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#&lt;init&gt;(cursor:monix.tail.batches.BatchCursor[A],rest:F[monix.tail.Iterant[F,A]],stop:F[Unit]):monix.tail.Iterant.NextCursor[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">NextCursor</span><span class="params">(<span name="cursor">cursor: <a href="batches/BatchCursor.html" class="extype" name="monix.tail.batches.BatchCursor">BatchCursor</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>, <span name="rest">rest: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>, <span name="stop">stop: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>)</span>
      </span>
      
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>is an <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/Iterator.html" class="extype" name="scala.collection.Iterator">Iterator</a> type
        that can generate elements by traversing a collection, a standard
        array or any <code>Iterator</code></p></dd><dt class="param">rest</dt><dd class="cmt"><p>is the next state in the sequence that
        will produce the rest of the stream when evaluated</p></dd><dt class="param">stop</dt><dd class="cmt"><p>is a computation to be executed in case
        streaming is stopped prematurely, giving it a chance
        to do resource cleanup (e.g. close file handles)</p></dd></dl></div>
    </li></ol>
            </div>

        

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="monix.tail.Iterant#++" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="++[B&gt;:A](rhs:monix.tail.Iterant[F,B])(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]"></a><a id="++[B&gt;:A](Iterant[F,B])(Applicative[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#++[B&gt;:A](rhs:monix.tail.Iterant[F,B])(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus$plus" class="name">++</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.++.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" class="extype" name="cats.Applicative">Applicative</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.++.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Appends the given stream to the end of the source, effectively
concatenating them.</p><div class="fullcomment"><div class="comment cmt"><p>Appends the given stream to the end of the source, effectively
concatenating them.</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2, 3, 4</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>) ++ Iterant[Task].of(<span class="num">3</span>, <span class="num">4</span>)</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the (right hand side) iterant to concatenate at
       the end of this iterant.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#++" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="++[B&gt;:A](rhs:F[monix.tail.Iterant[F,B]])(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]"></a><a id="++[B&gt;:A](F[Iterant[F,B]])(Applicative[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#++[B&gt;:A](rhs:F[monix.tail.Iterant[F,B]])(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus$plus" class="name">++</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="rhs">rhs: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.++.B">B</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" class="extype" name="cats.Applicative">Applicative</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.++.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Appends a stream to the end of the source, effectively
concatenating them.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a stream to the end of the source, effectively
concatenating them.</p><p>The right hand side is suspended in the <code>F[_]</code> data type, thus
allowing for laziness.</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2, 3, 4</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>) ++ Task.suspend {
  Iterant[Task].of(<span class="num">3</span>, <span class="num">4</span>)
}</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the iterant to append at the end of our source.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#+:" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="+:[B&gt;:A](head:B)(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]"></a><a id="+:[B&gt;:A](B)(Applicative[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#+:[B&gt;:A](head:B)(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus$colon" class="name">+:</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="head">head: <span class="extype" name="monix.tail.Iterant.+:.B">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" class="extype" name="cats.Applicative">Applicative</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.+:.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Prepends an element to the iterant, returning a new
iterant that will start with the given <code>head</code> and then
continue with the source.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends an element to the iterant, returning a new
iterant that will start with the given <code>head</code> and then
continue with the source.</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2, 3, 4</span>
<span class="num">1</span> +: Iterant[Task].of(<span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)</pre></div><dl class="paramcmts block"><dt class="param">head</dt><dd class="cmt"><p>is the element to prepend at the start of
       this iterant</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#:+" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id=":+[B&gt;:A](elem:B)(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]"></a><a id=":+[B&gt;:A](B)(Applicative[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#:+[B&gt;:A](elem:B)(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $colon$plus" class="name">:+</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="elem">elem: <span class="extype" name="monix.tail.Iterant.:+.B">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" class="extype" name="cats.Applicative">Applicative</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.:+.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Appends the right hand side element to the end of this iterant.</p><div class="fullcomment"><div class="comment cmt"><p>Appends the right hand side element to the end of this iterant.</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2, 3, 4</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>) :+ <span class="num">4</span></pre></div><dl class="paramcmts block"><dt class="param">elem</dt><dd class="cmt"><p>is the element to append at the end</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="monix.tail.Iterant#attempt" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="attempt(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Either[Throwable,A]]"></a><a id="attempt(Sync[F]):Iterant[F,Either[Throwable,A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#attempt(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Either[Throwable,A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">attempt</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Throwable">Throwable</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Converts the source <code>Iterant</code> that emits <code>A</code> elements into an
iterant that emits <code>Either[Throwable, A]</code>, thus materializing
whatever error that might interrupt the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source <code>Iterant</code> that emits <code>A</code> elements into an
iterant that emits <code>Either[Throwable, A]</code>, thus materializing
whatever error that might interrupt the stream.</p><p>Example: </p><pre><span class="cmt">// Yields Right(1), Right(2), Right(3)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).attempt


<span class="cmt">// Yields Right(1), Right(2), Left(DummyException())</span>
(Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>) ++
  Iterant[Task].raiseError(DummyException())).attempt</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#batched" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="batched(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="batched(Int)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#batched(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">batched</span><span class="params">(<span name="count">count: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Optimizes the access to the source by periodically gathering
items emitted into batches of the specified size and emitting
<a href="Iterant$$NextBatch.html" class="extype" name="monix.tail.Iterant.NextBatch">NextBatch</a> nodes.</p><div class="fullcomment"><div class="comment cmt"><p>Optimizes the access to the source by periodically gathering
items emitted into batches of the specified size and emitting
<a href="Iterant$$NextBatch.html" class="extype" name="monix.tail.Iterant.NextBatch">NextBatch</a> nodes.</p><p>For this operation we have this law:</p><pre>source.batched(<span class="num">16</span>) <span class="kw">&lt;-</span>&gt; source</pre><p>This means that the result will emit exactly what the source
emits, however the underlying representation will be different,
the emitted notes being of type <code>NextBatch</code>, wrapping arrays
with the length equal to the given <code>count</code>.</p><p>Very similar in behavior with <a href="Iterant.html#bufferTumbling(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]" class="extmbr" name="monix.tail.Iterant#bufferTumbling">bufferTumbling</a>, however the
batches are implicit, not explicit. Useful for optimization.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#bufferSliding" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bufferSliding(count:Int,skip:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]"></a><a id="bufferSliding(Int,Int)(Sync[F]):Iterant[F,Seq[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#bufferSliding(count:Int,skip:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bufferSliding</span><span class="params">(<span name="count">count: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>, <span name="skip">skip: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns an iterant that emits buffers of items it collects from
the source iterant.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an iterant that emits buffers of items it collects from
the source iterant. The resulting iterant emits buffers
every <code>skip</code> items, each containing <code>count</code> items.</p><p>If the source iterant completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.</p><p>For <code>count</code> and <code>skip</code> there are 3 possibilities:</p><ol class="decimal"><li>in case <code>skip == count</code>, then there are no items dropped and
    no overlap, the call being equivalent to <code>buffer(count)</code></li><li>in case <code>skip &lt; count</code>, then overlap between buffers
    happens, with the number of elements being repeated being
    <code>count - skip</code></li><li>in case <code>skip &gt; count</code>, then <code>skip - count</code> elements start
    getting dropped between windows</li></ol><p>Example:</p><pre><span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>, <span class="num">7</span>)

<span class="cmt">// Yields Seq(1, 2, 3), Seq(4, 5, 6), Seq(7)</span>
source.bufferSliding(<span class="num">3</span>, <span class="num">3</span>)

<span class="cmt">// Yields Seq(1, 2, 3), Seq(5, 6, 7)</span>
source.bufferSliding(<span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Yields Seq(1, 2, 3), Seq(3, 4, 5), Seq(5, 6, 7)</span>
source.bufferSliding(<span class="num">3</span>, <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>the maximum size of each buffer before it should
       be emitted</p></dd><dt class="param">skip</dt><dd class="cmt"><p>how many items emitted by the source iterant should
       be skipped before starting a new buffer. Note that when
       skip and count are equal, this is the same operation as
       <code>bufferTumbling(count)</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#bufferTumbling" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bufferTumbling(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]"></a><a id="bufferTumbling(Int)(Sync[F]):Iterant[F,Seq[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#bufferTumbling(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bufferTumbling</span><span class="params">(<span name="count">count: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Periodically gather items emitted by an iterant into bundles
and emit these bundles rather than emitting the items one at a
time.</p><div class="fullcomment"><div class="comment cmt"><p>Periodically gather items emitted by an iterant into bundles
and emit these bundles rather than emitting the items one at a
time. This version of <code>buffer</code> is emitting items once the
internal buffer has reached the given count.</p><p>If the source iterant completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.</p><pre><span class="cmt">// Yields Seq(1, 2, 3), Seq(4, 5, 6), Seq(7)</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>, <span class="num">7</span>).bufferTumbling(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>the maximum size of each buffer before it should
       be emitted</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#bufferSliding(count:Int,skip:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]" class="extmbr" name="monix.tail.Iterant#bufferSliding">bufferSliding</a> for the more flexible version that allows
     to specify a <code>skip</code> argument.</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="monix.tail.Iterant#collect" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collect[B](pf:PartialFunction[A,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="collect[B](PartialFunction[A,B])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#collect[B](pf:PartialFunction[A,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collect</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <a href="http://www.scala-lang.org/api/2.12.4/scala/PartialFunction.html#scala.PartialFunction" class="extype" name="scala.PartialFunction">PartialFunction</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <span class="extype" name="monix.tail.Iterant.collect.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.collect.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a new iterant by applying a partial function to all
elements of the source on which the function is defined.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a new iterant by applying a partial function to all
elements of the source on which the function is defined.</p><p>Example: </p><pre><span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>)
  .map { x <span class="kw">=&gt;</span> <span class="std">Option</span>(x).filter(_ % <span class="num">2</span> == <span class="num">0</span>) }
  .collect { <span class="kw">case</span> <span class="std">Some</span>(x) <span class="kw">=&gt;</span> x }</pre></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>the element type of the returned iterant.</p></dd><dt class="param">pf</dt><dd class="cmt"><p>the partial function that filters and maps the iterant</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant resulting from applying the partial
        function <code>pf</code> to each element on which it is defined and
        collecting the results. The order of the elements is
        preserved.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#completeL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="completeL(implicitF:cats.effect.Sync[F]):F[Unit]"></a><a id="completeL(Sync[F]):F[Unit]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#completeL(implicitF:cats.effect.Sync[F]):F[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">completeL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Upon evaluation of the result, consumes this iterant to
completion.</p><div class="fullcomment"><div class="comment cmt"><p>Upon evaluation of the result, consumes this iterant to
completion.</p><p>Example: </p><pre><span class="kw">val</span> onFinish: Task[<span class="std">Unit</span>] =
  iterant.completeL &gt;&gt; Task.eval(println(<span class="lit">"Done!"</span>))</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#concat" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="concat[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="concat[B](&lt;:&lt;[A,Iterant[F,B]],Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#concat[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">concat</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.concat.B">B</span>]]</span>, <span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.concat.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Alias for <a href="Iterant.html#concat[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#concat">concat</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <a href="Iterant.html#concat[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#concat">concat</a>.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#concatMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="concatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="concatMap[B]((A)⇒Iterant[F,B])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#concatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">concatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.concatMap.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.concatMap.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Alias for <a href="Iterant.html#flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#flatMap">flatMap</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <a href="Iterant.html#flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#flatMap">flatMap</a>.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#countL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="countL(implicitF:cats.effect.Sync[F]):F[Long]"></a><a id="countL(Sync[F]):F[Long]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#countL(implicitF:cats.effect.Sync[F]):F[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">countL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Long.html#scala.Long" class="extype" name="scala.Long">Long</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Counts the total number of elements emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Counts the total number of elements emitted by the source.</p><p>Example:</p><pre><span class="cmt">// Yields 100</span>
Iterant[IO].range(<span class="num">0</span>, <span class="num">100</span>).countL

<span class="cmt">// Yields 1</span>
Iterant[IO].pure(<span class="num">1</span>).countL

<span class="cmt">// Yields 0</span>
Iterant[IO].empty[<span class="std">Int</span>].countL</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant.NextCursor#cursor" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="cursor:monix.tail.batches.BatchCursor[A]"></a><a id="cursor:BatchCursor[A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#cursor:monix.tail.batches.BatchCursor[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">cursor</span><span class="result">: <a href="batches/BatchCursor.html" class="extype" name="monix.tail.batches.BatchCursor">BatchCursor</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      
    </li><li name="monix.tail.Iterant#distinctUntilChanged" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinctUntilChanged(implicitF:cats.effect.Sync[F],implicitA:cats.Eq[A]):monix.tail.Iterant[F,A]"></a><a id="distinctUntilChanged(Sync[F],Eq[A]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#distinctUntilChanged(implicitF:cats.effect.Sync[F],implicitA:cats.Eq[A]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinctUntilChanged</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="A">A: <span class="extype" name="cats.Eq">Eq</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Suppress duplicate consecutive items emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Suppress duplicate consecutive items emitted by the source.</p><p>Example:</p><pre><span class="cmt">// Yields 1, 2, 1, 3, 2, 4</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">4</span>, <span class="num">4</span>, <span class="num">4</span>)
  .distinctUntilChanged</pre><p>Duplication is detected by using the equality relationship
provided by the <code>cats.Eq</code> type class. This allows one to
override the equality operation being used (e.g. maybe the
default <code>.equals</code> is badly defined, or maybe you want reference
equality, so depending on use case).</p><p>In case type <code>A</code> is a primitive type and an <code>Eq[A]</code> instance
is not in scope, then you probably need this import:</p><pre><span class="kw">import</span> cats.instances.all._</pre><p>Or in case your type <code>A</code> does not have an <code>Eq[A]</code> instance
defined for it, then you can quickly define one like this:</p><pre><span class="kw">import</span> cats.Eq

<span class="kw">implicit</span> <span class="kw">val</span> eqA = Eq.fromUniversalEquals[A]</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Eq</code> instance that defines equality for <code>A</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#distinctUntilChangedByKey" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinctUntilChangedByKey[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Eq[K]):monix.tail.Iterant[F,A]"></a><a id="distinctUntilChangedByKey[K]((A)⇒K)(Sync[F],Eq[K]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#distinctUntilChangedByKey[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Eq[K]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinctUntilChangedByKey</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.distinctUntilChangedByKey.K">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="K">K: <span class="extype" name="cats.Eq">Eq</span>[<span class="extype" name="monix.tail.Iterant.distinctUntilChangedByKey.K">K</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given a function that returns a key for each element emitted by
the source, suppress consecutive duplicate items.</p><div class="fullcomment"><div class="comment cmt"><p>Given a function that returns a key for each element emitted by
the source, suppress consecutive duplicate items.</p><p>Example:</p><pre><span class="cmt">// Yields 1, 2, 3, 4</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">3</span>, <span class="num">2</span>, <span class="num">4</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">5</span>, <span class="num">7</span>, <span class="num">4</span>)
  .distinctUntilChangedBy(_ % <span class="num">2</span>)</pre><p>Duplication is detected by using the equality relationship
provided by the <code>cats.Eq</code> type class. This allows one to
override the equality operation being used (e.g. maybe the
default <code>.equals</code> is badly defined, or maybe you want reference
equality, so depending on use case).</p><p>In case type <code>K</code> is a primitive type and an <code>Eq[K]</code> instance
is not in scope, then you probably need this import:</p><pre><span class="kw">import</span> cats.instances.all._</pre><p>Or in case your type <code>K</code> does not have an <code>Eq[K]</code> instance
defined for it, then you can quickly define one like this:</p><pre><span class="kw">import</span> cats.Eq

<span class="kw">implicit</span> <span class="kw">val</span> eqK = Eq.fromUniversalEquals[K]</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is a function that returns a <code>K</code> key for each element,
       a value that's then used to do the deduplication</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <code>cats.Eq</code> instance that defines equality for
       the key type <code>K</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#doOnEarlyStop" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEarlyStop(f:F[Unit])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="doOnEarlyStop(F[Unit])(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#doOnEarlyStop(f:F[Unit])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEarlyStop</span><span class="params">(<span name="f">f: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given a routine make sure to execute it whenever
the consumer executes the current <code>stop</code> action.</p><div class="fullcomment"><div class="comment cmt"><p>Given a routine make sure to execute it whenever
the consumer executes the current <code>stop</code> action.</p><p>Example: </p><pre>iterant.doOnEarlyStop(Task.eval {
  println(<span class="lit">"Was stopped early!"</span>)
})</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function to execute on early stop</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#doOnFinish" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnFinish(f:Option[Throwable]=&gt;F[Unit])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="doOnFinish((Option[Throwable])⇒F[Unit])(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#doOnFinish(f:Option[Throwable]=&gt;F[Unit])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnFinish</span><span class="params">(<span name="f">f: (<a href="http://www.scala-lang.org/api/2.12.4/scala/Option.html#scala.Option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.Throwable">Throwable</span>]) ⇒ <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a new enumerator in which <code>f</code> is scheduled to be executed
on <a href="Iterant$$Halt.html" class="extype" name="monix.tail.Iterant.Halt">halt</a> or on <a href="Iterant.html#earlyStop(implicitF:cats.Applicative[F]):F[Unit]" class="extmbr" name="monix.tail.Iterant#earlyStop">earlyStop</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new enumerator in which <code>f</code> is scheduled to be executed
on <a href="Iterant$$Halt.html" class="extype" name="monix.tail.Iterant.Halt">halt</a> or on <a href="Iterant.html#earlyStop(implicitF:cats.Applicative[F]):F[Unit]" class="extmbr" name="monix.tail.Iterant#earlyStop">earlyStop</a>.</p><p>This would typically be used to release any resources acquired
by this enumerator.</p><p>Note that <a href="Iterant.html#doOnEarlyStop(f:F[Unit])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" class="extmbr" name="monix.tail.Iterant#doOnEarlyStop">doOnEarlyStop</a> is subsumed under this operation,
the given <code>f</code> being evaluated on both reaching the end or
canceling early.</p><p>Example: </p><pre>iterant.doOnEarlyStop(err <span class="kw">=&gt;</span> Task.eval {
  err <span class="kw">match</span> {
    <span class="kw">case</span> <span class="std">Some</span>(e) <span class="kw">=&gt;</span> log.error(e)
    <span class="kw">case</span> <span class="std">None</span> <span class="kw">=&gt;</span>
      println(<span class="lit">"Was consumed successfully!"</span>)
  }
})</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function to execute on early stop</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#drop" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="drop(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="drop(Int)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#drop(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">drop</span><span class="params">(<span name="n">n: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Drops the first <code>n</code> elements (from the start).</p><div class="fullcomment"><div class="comment cmt"><p>Drops the first <code>n</code> elements (from the start).</p><p>Example: </p><pre><span class="cmt">// Yields 4, 5</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).drop(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the number of elements to drop</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that drops the first <i>n</i> elements
        emitted by the source</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#dropLast" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dropLast(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="dropLast(Int)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#dropLast(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropLast</span><span class="params">(<span name="n">n: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Drops the last <code>n</code> elements (from the end).</p><div class="fullcomment"><div class="comment cmt"><p>Drops the last <code>n</code> elements (from the end).</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).dropLast(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the number of elements to drop</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that drops the last <i>n</i> elements
        emitted by the source</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#dropWhile" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dropWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="dropWhile((A)⇒Boolean)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#dropWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Drops the longest prefix of elements that satisfy the given
predicate and returns a new iterant that emits the rest.</p><div class="fullcomment"><div class="comment cmt"><p>Drops the longest prefix of elements that satisfy the given
predicate and returns a new iterant that emits the rest.</p><p>Example: </p><pre><span class="cmt">// Yields 4, 5</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).dropWhile(_ &lt; <span class="num">4</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the predicate used to test whether the current
       element should be dropped, if <code>true</code>, or to interrupt
       the dropping process, if <code>false</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that drops the elements of the source
        until the first time the given predicate returns <code>false</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#dropWhileWithIndex" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dropWhileWithIndex(p:(A,Int)=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="dropWhileWithIndex((A,Int)⇒Boolean)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#dropWhileWithIndex(p:(A,Int)=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropWhileWithIndex</span><span class="params">(<span name="p">p: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Drops the longest prefix of elements that satisfy the given
function and returns a new Iterant that emits the rest.</p><div class="fullcomment"><div class="comment cmt"><p>Drops the longest prefix of elements that satisfy the given
function and returns a new Iterant that emits the rest.</p><p>In comparison with <a href="Iterant.html#dropWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" class="extmbr" name="monix.tail.Iterant#dropWhile">dropWhile</a>, this version accepts a function
that takes an additional parameter: the zero-based index of the
element.</p><p>Example: </p><pre><span class="cmt">// Yields 3, 4, 5</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).dropWhile((value, index) <span class="kw">=&gt;</span> value &gt;= index * <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the predicate used to test whether the current
       element should be dropped, if <code>true</code>, or to interrupt
       the dropping process, if <code>false</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that drops the elements of the source
        until the first time the given predicate returns <code>false</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#dump" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dump(prefix:String,out:java.io.PrintStream)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="dump(String,PrintStream)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#dump(prefix:String,out:java.io.PrintStream)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dump</span><span class="params">(<span name="prefix">prefix: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="out">out: <span class="extype" name="java.io.PrintStream">PrintStream</span> = <span class="symbol">System.out</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Dumps incoming events to standard output with provided prefix.</p><div class="fullcomment"><div class="comment cmt"><p>Dumps incoming events to standard output with provided prefix.</p><p>Utility that can be used for debugging purposes.</p><p>Example: </p><pre>Iterant[Task].range(<span class="num">0</span>, <span class="num">4</span>)
  .dump(<span class="lit">"O"</span>)
  .completeL.runAsync

<span class="cmt">// Results in:</span>

<span class="num">0</span>: O --&gt; <span class="num">0</span>
<span class="num">1</span>: O --&gt; <span class="num">1</span>
<span class="num">2</span>: O --&gt; <span class="num">2</span>
<span class="num">3</span>: O --&gt; <span class="num">3</span>
<span class="num">4</span>: O completed</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant.NextCursor#earlyStop" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="earlyStop(implicitF:cats.Applicative[F]):F[Unit]"></a><a id="earlyStop(Applicative[F]):F[Unit]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#earlyStop(implicitF:cats.Applicative[F]):F[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">earlyStop</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" class="extype" name="cats.Applicative">Applicative</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a computation that should be evaluated in case the
streaming must stop before reaching the end.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a computation that should be evaluated in case the
streaming must stop before reaching the end.</p><p>This is useful to release any acquired resources, like opened
file handles or network sockets.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="monix.tail.Iterant.NextCursor">NextCursor</a> → <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="monix.tail.Iterant#existsL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="existsL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]"></a><a id="existsL((A)⇒Boolean)(Sync[F]):F[Boolean]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#existsL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">existsL</span><span class="params">(<span name="p">p: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns <code>true</code> in case the given predicate is satisfied by any
of the emitted items, or <code>false</code> in case the end of the stream
has been reached with no items satisfying the given predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> in case the given predicate is satisfied by any
of the emitted items, or <code>false</code> in case the end of the stream
has been reached with no items satisfying the given predicate.</p><p>Example: </p><pre><span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Yields true</span>
source.existsL(_ % <span class="num">2</span> == <span class="num">0</span>)

<span class="cmt">// Yields false</span>
source.existsL(_ % <span class="num">7</span> == <span class="num">0</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a predicate function that's going to test each item
       emitted by the source until we get a positive match for
       one of them or until the stream ends</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if any of the items satisfies the given predicate
       or <code>false</code> if none of them do</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#filter" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="filter(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="filter((A)⇒Boolean)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#filter(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="params">(<span name="p">p: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Filters the iterant by the given predicate function, returning
only those elements that match.</p><div class="fullcomment"><div class="comment cmt"><p>Filters the iterant by the given predicate function, returning
only those elements that match.</p><p>Example: </p><pre><span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).filter(_ % <span class="num">2</span> == <span class="num">0</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the predicate used to test elements.</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant consisting of all elements that satisfy
        the given predicate. The order of the elements is
        preserved.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="monix.tail.Iterant#findL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="findL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Option[A]]"></a><a id="findL((A)⇒Boolean)(Sync[F]):F[Option[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#findL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Option[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">findL</span><span class="params">(<span name="p">p: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Option.html#scala.Option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given a predicate, finds the first item that satisfies it,
returning <code>Some(a)</code> if available, or <code>None</code> otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Given a predicate, finds the first item that satisfies it,
returning <code>Some(a)</code> if available, or <code>None</code> otherwise.</p><pre><span class="cmt">// Yields Some(2)</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).findL(_ % <span class="num">2</span> == <span class="num">0</span>)

<span class="cmt">// Yields None</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).findL(_ &gt; <span class="num">10</span>)</pre><p>The stream is traversed from beginning to end, the process
being interrupted as soon as it finds one element matching
the predicate, or until the stream ends.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the function to test the elements of the source</p></dd><dt>returns</dt><dd class="cmt"><p>either <code>Some(value)</code> in case <code>value</code> is an element
        emitted by the source, found to satisfy the predicate,
        or <code>None</code> otherwise</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#flatMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="flatMap[B]((A)⇒Iterant[F,B])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.flatMap.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.flatMap.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Applies the function to the elements of the source and
concatenates the results.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the function to the elements of the source and
concatenates the results.</p><p>This operation is the monadic &quot;bind&quot;, with all laws it entails.</p><p>Also note that the implementation can use constant memory
depending on usage, thus it can be used in tail recursive loops.</p><p>Example: </p><pre><span class="cmt">// Effectively equivalent with .filter</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).flatMap { elem <span class="kw">=&gt;</span>
  <span class="kw">if</span> (elem % <span class="num">2</span> == <span class="num">0</span>)
    Iterant[Task].pure(elem)
  <span class="kw">else</span>
    Iterant[Task].empty
}</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function mapping elements from the
       source to iterants</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#flatten" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatten[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="flatten[B](&lt;:&lt;[A,Iterant[F,B]],Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#flatten[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatten</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.flatten.B">B</span>]]</span>, <span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.flatten.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given an <code>Iterant</code> that generates <code>Iterant</code> elements, concatenates
all the generated iterants.</p><div class="fullcomment"><div class="comment cmt"><p>Given an <code>Iterant</code> that generates <code>Iterant</code> elements, concatenates
all the generated iterants.</p><p>Equivalent with: <code>source.flatMap(x =&gt; x)</code>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#foldL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foldL(implicitF:cats.effect.Sync[F],implicitA:cats.Monoid[A]):F[A]"></a><a id="foldL(Sync[F],Monoid[A]):F[A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#foldL(implicitF:cats.effect.Sync[F],implicitA:cats.Monoid[A]):F[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="A">A: <span class="extype" name="cats.Monoid">Monoid</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given evidence that type <code>A</code> has a <code>cats.Monoid</code> implementation,
folds the stream with the provided monoid definition.</p><div class="fullcomment"><div class="comment cmt"><p>Given evidence that type <code>A</code> has a <code>cats.Monoid</code> implementation,
folds the stream with the provided monoid definition.</p><p>For streams emitting numbers, this effectively sums them up.
For strings, this concatenates them.</p><p>Example:</p><pre><span class="cmt">// Yields 10</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).foldL

<span class="cmt">// Yields "1234"</span>
Iterant[Task].of(<span class="lit">"1"</span>, <span class="lit">"2"</span>, <span class="lit">"3"</span>, <span class="lit">"4"</span>).foldL</pre><p>Note, in case you don't have a <code>Monoid</code> instance in scope,
but you feel like you should, try this import:</p><pre><span class="kw">import</span> cats.instances.all._</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Monoid</code> type class instance that's needed
         in scope for folding the source</p></dd><dt>returns</dt><dd class="cmt"><p>the result of combining all elements of the source,
        or the defined <code>Monoid.empty</code> element in case the
        stream is empty</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#foldLeftL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foldLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):F[S]"></a><a id="foldLeftL[S](⇒S)((S,A)⇒S)(Sync[F]):F[S]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#foldLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):F[S]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldLeftL</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: ⇒ <span class="extype" name="monix.tail.Iterant.foldLeftL.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="monix.tail.Iterant.foldLeftL.S">S</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.foldLeftL.S">S</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.foldLeftL.S">S</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Left associative fold using the function <code>op</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Left associative fold using the function <code>op</code>.</p><p>On execution the stream will be traversed from left to right,
and the given function will be called with the prior result,
accumulating state until the end, when the summary is returned.</p><p>Example: </p><pre><span class="cmt">// Yields 15 (1 + 2 + 3 + 4 + 5)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldLeftL(<span class="num">0</span>)(_ + _)</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the start value</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the binary operator</p></dd><dt>returns</dt><dd class="cmt"><p>the result of inserting <code>op</code> between consecutive
        elements of this iterant, going from left to right with
        the <code>seed</code> as the start value, or <code>seed</code> if the iterant
        is empty.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#foldRightL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foldRightL[B](b:F[B])(f:(A,F[B],F[Unit])=&gt;F[B])(implicitF:cats.effect.Sync[F]):F[B]"></a><a id="foldRightL[B](F[B])((A,F[B],F[Unit])⇒F[B])(Sync[F]):F[B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#foldRightL[B](b:F[B])(f:(A,F[B],F[Unit])=&gt;F[B])(implicitF:cats.effect.Sync[F]):F[B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldRightL</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="b">b: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.foldRightL.B">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.foldRightL.B">B</span>], <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]) ⇒ <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.foldRightL.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.foldRightL.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Lazily fold the stream to a single value from the right.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily fold the stream to a single value from the right.</p><p>This is the common <code>foldr</code> operation from Haskell's <code>Foldable</code>,
or <code>foldRight</code> from Scala's collections, however it has a twist:
the user is responsible for invoking early <code>stop</code> in case the
processing is short-circuited, hence the signature of function
<code>f</code> is different from other implementations, receiving the
current <code>earlyStop: F[Unit]</code> as a third parameter.</p><p>Here's for example how <a href="Iterant.html#existsL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]" class="extmbr" name="monix.tail.Iterant#existsL">existsL</a>, <a href="Iterant.html#forallL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]" class="extmbr" name="monix.tail.Iterant#forallL">forallL</a> and <code>++</code> could
be expressed in terms of <code>foldRightL</code>:</p><pre><span class="kw">def</span> exists[F[_], A](fa: Iterant[F, A], p: A <span class="kw">=&gt;</span> <span class="std">Boolean</span>)
  (<span class="kw">implicit</span> F: Sync[F]): F[<span class="std">Boolean</span>] = {

  fa.foldRightL(F.pure(<span class="kw">false</span>)) { (a, next, stop) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (p(a)) stop.map(_ <span class="kw">=&gt;</span> <span class="kw">true</span>) <span class="kw">else</span> next
  }
}

<span class="kw">def</span> forall[F[_], A](fa: Iterant[F, A], p: A <span class="kw">=&gt;</span> <span class="std">Boolean</span>)
  (<span class="kw">implicit</span> F: Sync[F]): F[<span class="std">Boolean</span>] = {

  fa.foldRightL(F.pure(<span class="kw">true</span>)) { (a, next, stop) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (!p(a)) stop.map(_ <span class="kw">=&gt;</span> <span class="kw">false</span>) <span class="kw">else</span> next
  }
}

<span class="kw">def</span> concat[F[_], A](lh: Iterant[F, A], rh: Iterant[F, A])
  (<span class="kw">implicit</span> F: Sync[F]): Iterant[F, A] = {

  Iterant.suspend[F, A] {
    lh.foldRightL(F.pure(rh)) { (a, rest, stop) <span class="kw">=&gt;</span>
      F.pure(Iterant.nextS(a, rest, stop))
    }
  }
}</pre><p>In this example we are short-circuiting the processing in case
we find the one element that we are looking for, otherwise we
keep traversing the stream until the end, finally returning
the default value in case we haven't found what we were looking
for.</p><h4>WARNING</h4><p>The implementation cannot ensure resource safety
automatically, therefore it falls on the user to chain the
<code>stop</code> reference in the processing, in case the right parameter
isn't factored in.</p><p>In other words:</p><ul><li>in case the processing fails in any way with exceptions,
   it is the user's responsibility to chain <code>stop</code></li><li>in case the processing is short-circuited by not using the
   <code>F[B]</code> right param, it is the user responsibility to chain
   <code>stop</code></li></ul><p>This is in contrast with all operators (unless explicitly
mentioned otherwise).</p><p>See the examples provided above, as they are correct in their
handling of <code>stop</code>.
</p></div><dl class="paramcmts block"><dt class="param">b</dt><dd class="cmt"><p>is the starting value; in case <code>f</code> is a binary operator,
       this is typically its left-identity (zero)</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the function to be called that folds the list,
       receiving the current element being iterated on
       (first param), the (lazy) result from recursively
       combining the rest of the list (second param) and
       the <code>earlyStop</code> routine, to chain in case
       short-circuiting should happen (third param)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]" class="extmbr" name="monix.tail.Iterant#foldWhileLeftL">foldWhileLeftL</a> and <a href="Iterant.html#foldWhileLeftEvalL[S](seed:F[S])(op:(S,A)=&gt;F[Either[S,S]])(implicitF:cats.effect.Sync[F]):F[S]" class="extmbr" name="monix.tail.Iterant#foldWhileLeftEvalL">foldWhileLeftEvalL</a> for safer
    alternatives in most cases</p></span></dd></dl></div>
    </li><li name="monix.tail.Iterant#foldWhileLeftEvalL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foldWhileLeftEvalL[S](seed:F[S])(op:(S,A)=&gt;F[Either[S,S]])(implicitF:cats.effect.Sync[F]):F[S]"></a><a id="foldWhileLeftEvalL[S](F[S])((S,A)⇒F[Either[S,S]])(Sync[F]):F[S]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#foldWhileLeftEvalL[S](seed:F[S])(op:(S,A)=&gt;F[Either[S,S]])(implicitF:cats.effect.Sync[F]):F[S]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldWhileLeftEvalL</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.foldWhileLeftEvalL.S">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="monix.tail.Iterant.foldWhileLeftEvalL.S">S</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="scala.Either">Either</span>[<span class="extype" name="monix.tail.Iterant.foldWhileLeftEvalL.S">S</span>, <span class="extype" name="monix.tail.Iterant.foldWhileLeftEvalL.S">S</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.foldWhileLeftEvalL.S">S</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Left associative fold using the function <code>op</code> that can be
short-circuited.</p><div class="fullcomment"><div class="comment cmt"><p>Left associative fold using the function <code>op</code> that can be
short-circuited.</p><p>On execution the stream will be traversed from left to right,
and the given function will be called with the prior result,
accumulating state either until the end, or until <code>op</code> returns
a <code>Right</code> result, when the summary is returned.</p><p>The results are returned in the <code>F[_]</code> functor context, meaning
that we can have lazy or asynchronous processing and we can
suspend side effects, depending on the <code>F</code> data type being used.</p><p>Example using <code>cats.effect.IO</code>: </p><pre><span class="cmt">// Sums first 10 items</span>
Iterant[IO].range(<span class="num">0</span>, <span class="num">1000</span>).foldWhileLeftEvalL(IO((<span class="num">0</span>, <span class="num">0</span>))) {
  <span class="kw">case</span> ((sum, count), e) <span class="kw">=&gt;</span>
    IO {
      <span class="kw">val</span> next = (sum + e, count + <span class="num">1</span>)
      <span class="kw">if</span> (count + <span class="num">1</span> &lt; <span class="num">10</span>) Left(next) <span class="kw">else</span> Right(next)
    }
}

<span class="cmt">// Implements exists(predicate)</span>
Iterant[IO].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftEvalL(IO(<span class="kw">false</span>)) {
  (default, e) <span class="kw">=&gt;</span>
    IO { <span class="kw">if</span> (e == <span class="num">3</span>) Right(<span class="kw">true</span>) <span class="kw">else</span> Left(default) }
}

<span class="cmt">// Implements forall(predicate)</span>
Iterant[IO].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftEvalL(IO(<span class="kw">true</span>)) {
  (default, e) <span class="kw">=&gt;</span>
    IO { <span class="kw">if</span> (e != <span class="num">3</span>) Right(<span class="kw">false</span>) <span class="kw">else</span> Left(default) }
}</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the start value</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the binary operator returning either <code>Left</code>,
       signaling that the state should be evolved or a <code>Right</code>,
       signaling that the process can be short-circuited and
       the result returned immediately</p></dd><dt>returns</dt><dd class="cmt"><p>the result of inserting <code>op</code> between consecutive
        elements of this iterant, going from left to right with
        the <code>seed</code> as the start value, or <code>seed</code> if the iterant
        is empty</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]" class="extmbr" name="monix.tail.Iterant#foldWhileLeftL">Iterant.foldWhileLeftL</a> for the strict version.</p></span></dd></dl></div>
    </li><li name="monix.tail.Iterant#foldWhileLeftL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]"></a><a id="foldWhileLeftL[S](⇒S)((S,A)⇒Either[S,S])(Sync[F]):F[S]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldWhileLeftL</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: ⇒ <span class="extype" name="monix.tail.Iterant.foldWhileLeftL.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="monix.tail.Iterant.foldWhileLeftL.S">S</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="monix.tail.Iterant.foldWhileLeftL.S">S</span>, <span class="extype" name="monix.tail.Iterant.foldWhileLeftL.S">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.foldWhileLeftL.S">S</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Left associative fold using the function <code>op</code> that can be
short-circuited.</p><div class="fullcomment"><div class="comment cmt"><p>Left associative fold using the function <code>op</code> that can be
short-circuited.</p><p>On execution the stream will be traversed from left to right,
and the given function will be called with the prior result,
accumulating state either until the end, or until <code>op</code> returns
a <code>Right</code> result, when the summary is returned.</p><p>Example: </p><pre><span class="cmt">// Sums first 10 items</span>
Iterant[Task].range(<span class="num">0</span>, <span class="num">1000</span>).foldWhileLeftL((<span class="num">0</span>, <span class="num">0</span>)) {
  <span class="kw">case</span> ((sum, count), e) <span class="kw">=&gt;</span>
    <span class="kw">val</span> next = (sum + e, count + <span class="num">1</span>)
    <span class="kw">if</span> (count + <span class="num">1</span> &lt; <span class="num">10</span>) Left(next) <span class="kw">else</span> Right(next)
}

<span class="cmt">// Implements exists(predicate)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftL(<span class="kw">false</span>) {
  (default, e) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (e == <span class="num">3</span>) Right(<span class="kw">true</span>) <span class="kw">else</span> Left(default)
}

<span class="cmt">// Implements forall(predicate)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftL(<span class="kw">true</span>) {
  (default, e) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (e != <span class="num">3</span>) Right(<span class="kw">false</span>) <span class="kw">else</span> Left(default)
}</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the start value</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the binary operator returning either <code>Left</code>,
       signaling that the state should be evolved or a <code>Right</code>,
       signaling that the process can be short-circuited and
       the result returned immediately</p></dd><dt>returns</dt><dd class="cmt"><p>the result of inserting <code>op</code> between consecutive
        elements of this iterant, going from left to right with
        the <code>seed</code> as the start value, or <code>seed</code> if the iterant
        is empty</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]" class="extmbr" name="monix.tail.Iterant#foldWhileLeftL">Iterant.foldWhileLeftL</a> for the lazy, potentially
     asynchronous version.</p></span></dd></dl></div>
    </li><li name="monix.tail.Iterant#forallL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="forallL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]"></a><a id="forallL((A)⇒Boolean)(Sync[F]):F[Boolean]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#forallL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">forallL</span><span class="params">(<span name="p">p: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns <code>true</code> in case the given predicate is satisfied by all
of the emitted items, or <code>false</code> in case the given predicate
fails for any of those items.</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> in case the given predicate is satisfied by all
of the emitted items, or <code>false</code> in case the given predicate
fails for any of those items.</p><p>Example: </p><pre><span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Yields false</span>
source.forallL(_ % <span class="num">2</span> == <span class="num">0</span>)

<span class="cmt">// Yields true</span>
source.existsL(_ &lt; <span class="num">10</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a predicate function that's going to test each item
       emitted by the source until we get a negative match for
       one of them or until the stream ends</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if all of the items satisfy the given predicate
       or <code>false</code> if any of them don't</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#foreach" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foreach(cb:A=&gt;Unit)(implicitF:cats.effect.Sync[F]):F[Unit]"></a><a id="foreach((A)⇒Unit)(Sync[F]):F[Unit]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#foreach(cb:A=&gt;Unit)(implicitF:cats.effect.Sync[F]):F[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foreach</span><span class="params">(<span name="cb">cb: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes the source iterable, executing the given callback for
each element.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes the source iterable, executing the given callback for
each element.</p><p>Example: </p><pre><span class="cmt">// Prints all elements, each one on a different line</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).foreachL { elem <span class="kw">=&gt;</span>
  println(<span class="lit">"Elem: "</span> + elem.toString)
}</pre></div><dl class="paramcmts block"><dt class="param">cb</dt><dd class="cmt"><p>is the callback to call for each element emitted
       by the source.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="monix.tail.Iterant#headOptionL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="headOptionL(implicitF:cats.effect.Sync[F]):F[Option[A]]"></a><a id="headOptionL(Sync[F]):F[Option[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#headOptionL(implicitF:cats.effect.Sync[F]):F[Option[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headOptionL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Option.html#scala.Option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Optionally selects the first element.</p><div class="fullcomment"><div class="comment cmt"><p>Optionally selects the first element.</p><pre><span class="cmt">// Yields Some(1)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).headOptionL

<span class="cmt">// Yields None</span>
Iterant[Task].empty[<span class="std">Int</span>].headOptionL</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the first element of this iterant if it is nonempty, or
        <code>None</code> if it is empty, in the <code>F</code> context.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#interleave" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="interleave[B&gt;:A](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="interleave[B&gt;:A](Iterant[F,B])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#interleave[B&gt;:A](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">interleave</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.interleave.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.interleave.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Lazily interleaves two iterants together, starting with the first
element from <code>self</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily interleaves two iterants together, starting with the first
element from <code>self</code>.</p><p>The length of the result will be the shorter of the two
arguments.</p><p>Example: </p><pre><span class="kw">val</span> lh = Iterant[Task].of(<span class="num">11</span>, <span class="num">12</span>)
<span class="kw">val</span> rh = Iterant[Task].of(<span class="num">21</span>, <span class="num">22</span>, <span class="num">23</span>)

<span class="cmt">// Yields 11, 21, 12, 22</span>
lh.interleave(rh)</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to interleave the source with (the
       right hand side)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#intersperse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="intersperse(start:A,separator:A,end:A)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="intersperse(A,A,A)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#intersperse(start:A,separator:A,end:A)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">intersperse</span><span class="params">(<span name="start">start: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>, <span name="separator">separator: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>, <span name="end">end: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a new stream from the source that will emit the <code>start</code> element
followed by the upstream elements paired with the <code>separator</code>
and lastly the <code>end</code> element.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new stream from the source that will emit the <code>start</code> element
followed by the upstream elements paired with the <code>separator</code>
and lastly the <code>end</code> element.</p><pre><span class="cmt">// Yields '<', 'a', '-', 'b', '>'</span>
Iterant[Coeval].of(<span class="lit">'a'</span>, <span class="lit">'b'</span>).intersperse(<span class="lit">'<'</span>, <span class="lit">'-'</span>, <span class="lit">'>'</span>)</pre></div><dl class="paramcmts block"><dt class="param">start</dt><dd class="cmt"><p>the first element emitted</p></dd><dt class="param">separator</dt><dd class="cmt"><p>the separator</p></dd><dt class="param">end</dt><dd class="cmt"><p>the last element emitted</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#intersperse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="intersperse(separator:A)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="intersperse(A)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#intersperse(separator:A)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">intersperse</span><span class="params">(<span name="separator">separator: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a new stream from the source that will emit a specific <code>separator</code>
between every pair of elements.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new stream from the source that will emit a specific <code>separator</code>
between every pair of elements.</p><pre><span class="cmt">// Yields 1, 0, 2, 0, 3</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).intersperse(<span class="num">0</span>)</pre></div><dl class="paramcmts block"><dt class="param">separator</dt><dd class="cmt"><p>the separator</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="monix.tail.Iterant#liftMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="liftMap[G[_]](f1:F[monix.tail.Iterant[F,A]]=&gt;G[monix.tail.Iterant[F,A]],f2:F[Unit]=&gt;G[Unit])(implicitF:cats.Applicative[F],implicitG:cats.effect.Sync[G]):monix.tail.Iterant[G,A]"></a><a id="liftMap[G[_]]((F[Iterant[F,A]])⇒G[Iterant[F,A]],(F[Unit])⇒G[Unit])(Applicative[F],Sync[G]):Iterant[G,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#liftMap[G[_]](f1:F[monix.tail.Iterant[F,A]]=&gt;G[monix.tail.Iterant[F,A]],f2:F[Unit]=&gt;G[Unit])(implicitF:cats.Applicative[F],implicitG:cats.effect.Sync[G]):monix.tail.Iterant[G,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">liftMap</span><span class="tparams">[<span name="G">G<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="f1">f1: (<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]) ⇒ <span class="extype" name="monix.tail.Iterant.liftMap.G">G</span>[<a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>, <span name="f2">f2: (<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]) ⇒ <span class="extype" name="monix.tail.Iterant.liftMap.G">G</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" class="extype" name="cats.Applicative">Applicative</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="G">G: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.liftMap.G">G</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.liftMap.G">G</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given mapping functions from <code>F</code> to <code>G</code>, lifts the source into
an iterant that is going to use the resulting <code>G</code> for evaluation.</p><div class="fullcomment"><div class="comment cmt"><p>Given mapping functions from <code>F</code> to <code>G</code>, lifts the source into
an iterant that is going to use the resulting <code>G</code> for evaluation.</p><p>This can be used for replacing the underlying <code>F</code> type into
something else. For example say we have an iterant that uses
<a href="../eval/Coeval.html" class="extype" name="monix.eval.Coeval">Coeval</a>, but we want to convert it into
one that uses <a href="../eval/Task.html" class="extype" name="monix.eval.Task">Task</a> for evaluation:</p><pre><span class="cmt">// Source is using Coeval for evaluation</span>
<span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Transformation to an iterant based on Task</span>
source.liftMap(_.toTask, _.toTask)</pre></div><dl class="paramcmts block"><dt class="tparam">G</dt><dd class="cmt"><p>is the data type that is going to drive the evaluation
          of the resulting iterant</p></dd><dt class="param">f1</dt><dd class="cmt"><p>is the functor transformation used for transforming
         <code>rest</code> references</p></dd><dt class="param">f2</dt><dd class="cmt"><p>is the mapping function for early <code>stop</code> references</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#liftMapK" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="liftMapK[G[_]](f:cats.arrow.FunctionK[F,G])(implicitG:cats.effect.Sync[G]):monix.tail.Iterant[G,A]"></a><a id="liftMapK[G[_]](FunctionK[F,G])(Sync[G]):Iterant[G,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#liftMapK[G[_]](f:cats.arrow.FunctionK[F,G])(implicitG:cats.effect.Sync[G]):monix.tail.Iterant[G,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">liftMapK</span><span class="tparams">[<span name="G">G<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="f">f: <a href="http://typelevel.org/cats/api/cats/arrow/FunctionK.html#cats.arrow.FunctionK" class="extype" name="cats.arrow.FunctionK">FunctionK</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.liftMapK.G">G</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="G">G: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.liftMapK.G">G</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.liftMapK.G">G</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given a functor transformation from <code>F</code> to <code>G</code>, lifts the source
into an iterant that is going to use the resulting <code>G</code> for
evaluation.</p><div class="fullcomment"><div class="comment cmt"><p>Given a functor transformation from <code>F</code> to <code>G</code>, lifts the source
into an iterant that is going to use the resulting <code>G</code> for
evaluation.</p><p>This can be used for replacing the underlying <code>F</code> type into
something else. For example say we have an iterant that uses
<a href="../eval/Coeval.html" class="extype" name="monix.eval.Coeval">Coeval</a>, but we want to convert it into
one that uses <a href="../eval/Task.html" class="extype" name="monix.eval.Task">Task</a> for evaluation:</p><pre><span class="kw">import</span> cats.~&gt;

<span class="cmt">// Source is using Coeval for evaluation</span>
<span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Transformation to an iterant based on Task</span>
source.liftMapK(<span class="kw">new</span> (Coeval ~&gt; Task) {
  <span class="kw">def</span> apply[A](fa: Coeval[A]): Task[A] =
    fa.task
})</pre><p>This operator can be used for more than transforming the <code>F</code>
type into something else.
</p></div><dl class="paramcmts block"><dt class="tparam">G</dt><dd class="cmt"><p>is the data type that is going to drive the evaluation
          of the resulting iterant</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the functor transformation that's used to transform
         the source into an iterant that uses <code>G</code> for evaluation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#map" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="map[B]((A)⇒B)(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#map[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.map.B">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.map.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a new stream by mapping the supplied function over the
elements of the source.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new stream by mapping the supplied function over the
elements of the source.</p><pre><span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).map(_ * <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that transforms the source</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that's the result of mapping the given
        function over the source</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#mapEval" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mapEval[B](f:A=&gt;F[B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="mapEval[B]((A)⇒F[B])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#mapEval[B](f:A=&gt;F[B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapEval</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.mapEval.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.mapEval.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given a mapping function that returns a possibly lazy or
asynchronous result, applies it over the elements emitted by the
stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that returns a possibly lazy or
asynchronous result, applies it over the elements emitted by the
stream.</p><pre>Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).mapEval { elem <span class="kw">=&gt;</span>
  Task.eval {
    println(<span class="lit">"Received: "</span> + elem.toString)
    elem * <span class="num">2</span>
  }
}</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that transforms the source</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that's the result of mapping the given
        function over the source,</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#maxByL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="maxByL[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Order[K]):F[Option[A]]"></a><a id="maxByL[K]((A)⇒K)(Sync[F],Order[K]):F[Option[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#maxByL[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Order[K]):F[Option[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">maxByL</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.maxByL.K">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="K">K: <span class="extype" name="cats.Order">Order</span>[<span class="extype" name="monix.tail.Iterant.maxByL.K">K</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Option.html#scala.Option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Takes the elements of the source iterant and emits the
element that has the maximum key value, where the key is
generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the elements of the source iterant and emits the
element that has the maximum key value, where the key is
generated by the given function.</p><p>Example:</p><pre><span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Yields Some(Person("Peter", 23))</span>
Iterant[Coeval].of(Person(<span class="lit">"Peter"</span>, <span class="num">23</span>), Person(<span class="lit">"May"</span>, <span class="num">21</span>))
  .maxByL(_.age)

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[<span class="std">Int</span>].maxByL(_.age)</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is the function that returns the key for which the
           given ordering is defined</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <code>cats.Order</code> type class instance that's going
          to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the maximum element of the source stream, relative
        to its key generated by the given function and the
        given ordering</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#maxL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="maxL(implicitF:cats.effect.Sync[F],implicitA:cats.Order[A]):F[Option[A]]"></a><a id="maxL(Sync[F],Order[A]):F[Option[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#maxL(implicitF:cats.effect.Sync[F],implicitA:cats.Order[A]):F[Option[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">maxL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="A">A: <span class="extype" name="cats.Order">Order</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Option.html#scala.Option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given a <code>cats.Order</code> over the stream's elements, returns the
maximum element in the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>cats.Order</code> over the stream's elements, returns the
maximum element in the stream.</p><p>Example:</p><pre><span class="cmt">// Yields Some(20)</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">10</span>, <span class="num">7</span>, <span class="num">6</span>, <span class="num">8</span>, <span class="num">20</span>, <span class="num">3</span>, <span class="num">5</span>).maxL

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[<span class="std">Int</span>].maxL</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Order</code> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the maximum element of the source stream, relative
        to the defined <code>Order</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#minByL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="minByL[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Order[K]):F[Option[A]]"></a><a id="minByL[K]((A)⇒K)(Sync[F],Order[K]):F[Option[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#minByL[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Order[K]):F[Option[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">minByL</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.minByL.K">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="K">K: <span class="extype" name="cats.Order">Order</span>[<span class="extype" name="monix.tail.Iterant.minByL.K">K</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Option.html#scala.Option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Takes the elements of the source iterant and emits the
element that has the minimum key value, where the key is
generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the elements of the source iterant and emits the
element that has the minimum key value, where the key is
generated by the given function.</p><p>Example:</p><pre><span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Yields Some(Person("May", 21))</span>
Iterant[Coeval].of(Person(<span class="lit">"Peter"</span>, <span class="num">23</span>), Person(<span class="lit">"May"</span>, <span class="num">21</span>))
  .minByL(_.age)

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[<span class="std">Int</span>].minByL(_.age)</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is the function that returns the key for which the
           given ordering is defined</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <code>cats.Order</code> type class instance that's going
          to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the minimum element of the source stream, relative
        to its key generated by the given function and the
        given ordering</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#minL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="minL(implicitF:cats.effect.Sync[F],implicitA:cats.Order[A]):F[Option[A]]"></a><a id="minL(Sync[F],Order[A]):F[Option[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#minL(implicitF:cats.effect.Sync[F],implicitA:cats.Order[A]):F[Option[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">minL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="A">A: <span class="extype" name="cats.Order">Order</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Option.html#scala.Option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given a <code>cats.Order</code> over the stream's elements, returns the
minimum element in the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>cats.Order</code> over the stream's elements, returns the
minimum element in the stream.</p><p>Example:</p><pre><span class="cmt">// Yields Some(3)</span>
Iterant[Coeval].of(<span class="num">10</span>, <span class="num">7</span>, <span class="num">6</span>, <span class="num">8</span>, <span class="num">20</span>, <span class="num">3</span>, <span class="num">5</span>).minL

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[<span class="std">Int</span>].minL</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Order</code> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the minimum element of the source stream, relative
        to the defined <code>Order</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="monix.tail.Iterant#onErrorHandle" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorHandle[B&gt;:A](f:Throwable=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="onErrorHandle[B&gt;:A]((Throwable)⇒B)(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#onErrorHandle[B&gt;:A](f:Throwable=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorHandle</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="monix.tail.Iterant.onErrorHandle.B">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.onErrorHandle.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which
case the streaming of events fallbacks to an iterant
emitting a single element generated by the backup function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which
case the streaming of events fallbacks to an iterant
emitting a single element generated by the backup function.</p><p>Example: </p><pre><span class="kw">val</span> prefix = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)
<span class="kw">val</span> suffix = Iterant[Task].raiseError(DummyException(<span class="lit">"dummy"</span>))
<span class="kw">val</span> fa = prefix ++ suffix

fa.onErrorHandle { _ <span class="kw">=&gt;</span> <span class="num">5</span> }</pre><p>See <a href="Iterant.html#onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#onErrorRecover">onErrorRecover</a> for the version that takes a
partial function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a function that matches errors with a
       backup element that is emitted when the source
       throws an error.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#onErrorHandleWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="onErrorHandleWith[B&gt;:A]((Throwable)⇒Iterant[F,B])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorHandleWith</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.onErrorHandleWith.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.onErrorHandleWith.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which case
the streaming of events continues with the specified backup
sequence generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which case
the streaming of events continues with the specified backup
sequence generated by the given function.</p><p>Example: </p><pre><span class="kw">val</span> prefix = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)
<span class="kw">val</span> suffix = Iterant[Task].raiseError(DummyException(<span class="lit">"dummy"</span>))
<span class="kw">val</span> fa = prefix ++ suffix

fa.onErrorHandleWith {
  <span class="kw">case</span> _: DummyException <span class="kw">=&gt;</span>
    Iterant[Task].pure(<span class="num">5</span>)
  <span class="kw">case</span> other <span class="kw">=&gt;</span>
    Iterant[Task].raiseError(other)
}</pre><p>See <a href="Iterant.html#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.tail.Iterant[F,B]])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#onErrorRecoverWith">onErrorRecoverWith</a> for the version that takes a partial
function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a function that matches errors with a
       backup throwable that is subscribed when the source
       throws an error.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#onErrorIgnore" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorIgnore(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="onErrorIgnore(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#onErrorIgnore(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorIgnore</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a new <code>Iterant</code> that mirrors the source, but ignores
any errors in case they happen.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Iterant</code> that mirrors the source, but ignores
any errors in case they happen.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#onErrorRecover" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="onErrorRecover[B&gt;:A](PartialFunction[Throwable,B])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorRecover</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="http://www.scala-lang.org/api/2.12.4/scala/PartialFunction.html#scala.PartialFunction" class="extype" name="scala.PartialFunction">PartialFunction</a>[<span class="extype" name="scala.Throwable">Throwable</span>, <span class="extype" name="monix.tail.Iterant.onErrorRecover.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.onErrorRecover.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which
case the streaming of events fallbacks to an iterant
emitting a single element generated by the backup function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which
case the streaming of events fallbacks to an iterant
emitting a single element generated by the backup function.</p><p>The created <code>Iterant</code> mirrors the behavior of the source
in case the source does not end with an error or if the
thrown <code>Throwable</code> is not matched.</p><p>Example: </p><pre><span class="kw">val</span> prefix = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)
<span class="kw">val</span> suffix = Iterant[Task].raiseError(DummyException(<span class="lit">"dummy"</span>))
<span class="kw">val</span> fa = prefix ++ suffix

fa.onErrorRecover {
  <span class="kw">case</span> _: DummyException <span class="kw">=&gt;</span> <span class="num">5</span>
}</pre><p>See <a href="Iterant.html#onErrorHandle[B&gt;:A](f:Throwable=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#onErrorHandle">onErrorHandle</a> for the version that takes a
total function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>- a function that matches errors with a
       backup element that is emitted when the source
       throws an error.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#onErrorRecoverWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.tail.Iterant[F,B]])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="onErrorRecoverWith[B&gt;:A](PartialFunction[Throwable,Iterant[F,B]])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.tail.Iterant[F,B]])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorRecoverWith</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="http://www.scala-lang.org/api/2.12.4/scala/PartialFunction.html#scala.PartialFunction" class="extype" name="scala.PartialFunction">PartialFunction</a>[<span class="extype" name="scala.Throwable">Throwable</span>, <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.onErrorRecoverWith.B">B</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.onErrorRecoverWith.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which case
the streaming of events continues with the specified backup
sequence generated by the given partial function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which case
the streaming of events continues with the specified backup
sequence generated by the given partial function.</p><p>The created <code>Iterant</code> mirrors the behavior of the source in
case the source does not end with an error or if the thrown
<code>Throwable</code> is not matched.</p><p>Example: </p><pre><span class="kw">val</span> prefix = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)
<span class="kw">val</span> suffix = Iterant[Task].raiseError(DummyException(<span class="lit">"dummy"</span>))
<span class="kw">val</span> fa = prefix ++ suffix

fa.onErrorRecoverWith {
  <span class="kw">case</span> _: DummyException <span class="kw">=&gt;</span>
    Iterant[Task].pure(<span class="num">5</span>)
}</pre><p>See <a href="Iterant.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#onErrorHandleWith">onErrorHandleWith</a> for the version that takes a total
function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>is a function that matches errors with a
       backup throwable that is subscribed when the source
       throws an error.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#parZip" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parZip[G[_],B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F],implicitP:cats.Parallel[F,G]):monix.tail.Iterant[F,(A,B)]"></a><a id="parZip[G[_],B](Iterant[F,B])(Sync[F],Parallel[F,G]):Iterant[F,(A,B)]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#parZip[G[_],B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F],implicitP:cats.Parallel[F,G]):monix.tail.Iterant[F,(A,B)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parZip</span><span class="tparams">[<span name="G">G<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.parZip.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="P">P: <a href="http://typelevel.org/cats/api/cats/Parallel.html#cats.Parallel" class="extype" name="cats.Parallel">Parallel</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.parZip.G">G</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <span class="extype" name="monix.tail.Iterant.parZip.B">B</span>)]</span>
      </span>
      
      <p class="shortcomment cmt">Lazily zip two iterants together, the elements of the emitted
tuples being fetched in parallel.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily zip two iterants together, the elements of the emitted
tuples being fetched in parallel.</p><p>This is the parallel version of <a href="Iterant.html#zip[B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,B)]" class="extmbr" name="monix.tail.Iterant#zip">zip</a>, the results are
still ordered, but it can yield non-deterministic ordering
of effects when fetching the elements of an emitted tuple.
</p></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to zip the source with (the
       right hand side)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#parZipMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parZipMap[G[_],B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F],implicitP:cats.Parallel[F,G]):monix.tail.Iterant[F,C]"></a><a id="parZipMap[G[_],B,C](Iterant[F,B])((A,B)⇒C)(Sync[F],Parallel[F,G]):Iterant[F,C]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#parZipMap[G[_],B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F],implicitP:cats.Parallel[F,G]):monix.tail.Iterant[F,C]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parZipMap</span><span class="tparams">[<span name="G">G<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.parZipMap.B">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <span class="extype" name="monix.tail.Iterant.parZipMap.B">B</span>) ⇒ <span class="extype" name="monix.tail.Iterant.parZipMap.C">C</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="P">P: <a href="http://typelevel.org/cats/api/cats/Parallel.html#cats.Parallel" class="extype" name="cats.Parallel">Parallel</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.parZipMap.G">G</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.parZipMap.C">C</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Lazily zip two iterants together, in parallel, using the given
function <code>f</code> to produce output values.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily zip two iterants together, in parallel, using the given
function <code>f</code> to produce output values.</p><p>This is like <a href="Iterant.html#zipMap[B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,C]" class="extmbr" name="monix.tail.Iterant#zipMap">zipMap</a>, except that the element pairs are
processed in parallel (ordered results, but non-deterministic
ordering of effects).
</p></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to zip the source with (the
       right hand side)</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the mapping function to transform the zipped
       <code>(A, B)</code> elements</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#reduceL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduceL(op:(A,A)=&gt;A)(implicitF:cats.effect.Sync[F]):F[Option[A]]"></a><a id="reduceL((A,A)⇒A)(Sync[F]):F[Option[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#reduceL(op:(A,A)=&gt;A)(implicitF:cats.effect.Sync[F]):F[Option[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceL</span><span class="params">(<span name="op">op: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Option.html#scala.Option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Reduces the elements of the source using the specified
associative binary operator, going from left to right, start to
finish.</p><div class="fullcomment"><div class="comment cmt"><p>Reduces the elements of the source using the specified
associative binary operator, going from left to right, start to
finish.</p><p>Example:</p><pre><span class="cmt">// Yields Some(10)</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).reduceL(_ + _)

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[<span class="std">Int</span>].reduceL(_ + _)</pre></div><dl class="paramcmts block"><dt class="param">op</dt><dd class="cmt"><p>is an associative binary operation that's going
          to be used to reduce the source to a single value</p></dd><dt>returns</dt><dd class="cmt"><p>either <code>Some(value)</code> in case the stream is not empty,
        <code>value</code> being the result of inserting <code>op</code> between
        consecutive elements of this iterant, going from left
        to right, or <code>None</code> in case the stream is empty</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#repeat" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repeat(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="repeat(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#repeat(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repeat</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Repeats the items emitted by the source continuously</p><div class="fullcomment"><div class="comment cmt"><p>Repeats the items emitted by the source continuously</p><p>It terminates either on error or if the source is empty.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant.NextCursor#rest" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="rest:F[monix.tail.Iterant[F,A]]"></a><a id="rest:F[Iterant[F,A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#rest:F[monix.tail.Iterant[F,A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">rest</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      
    </li><li name="monix.tail.Iterant#scan" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]"></a><a id="scan[S](⇒S)((S,A)⇒S)(Sync[F]):Iterant[F,S]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: ⇒ <span class="extype" name="monix.tail.Iterant.scan.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="monix.tail.Iterant.scan.S">S</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.scan.S">S</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.scan.S">S</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><p>Similar to <a href="Iterant.html#foldLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):F[S]" class="extmbr" name="monix.tail.Iterant#foldLeftL">foldLeftL</a>, but emits the state on each
step. Useful for modeling finite state machines.</p><p>Example showing how state can be evolved and acted upon:</p><pre><span class="kw">sealed</span> <span class="kw">trait</span> State[+A] { <span class="kw">def</span> count: <span class="std">Int</span> }
<span class="kw">case</span> <span class="kw">object</span> Init <span class="kw">extends</span> State[<span class="std">Nothing</span>] { <span class="kw">def</span> count = <span class="num">0</span> }
<span class="kw">case</span> <span class="kw">class</span> Current[A](current: A, count: <span class="std">Int</span>) <span class="kw">extends</span> State[A]

<span class="kw">val</span> scanned = source.scan(Init : State[A]) { (acc, a) <span class="kw">=&gt;</span>
  acc <span class="kw">match</span> {
    <span class="kw">case</span> Init <span class="kw">=&gt;</span> Current(a, <span class="num">1</span>)
    <span class="kw">case</span> Current(_, count) <span class="kw">=&gt;</span> Current(a, count + <span class="num">1</span>)
  }
}

scanned
  .takeWhile(_.count &lt; <span class="num">10</span>)
  .collect { <span class="kw">case</span> Current(a, _) <span class="kw">=&gt;</span> a }</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the function that evolves the current state</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that emits all intermediate states being
        resulted from applying function <code>op</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#scanEval" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scanEval[S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]"></a><a id="scanEval[S](F[S])((S,A)⇒F[S])(Sync[F]):Iterant[F,S]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#scanEval[S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanEval</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.scanEval.S">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="monix.tail.Iterant.scanEval.S">S</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.scanEval.S">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.scanEval.S">S</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><p>Similar with <a href="Iterant.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" class="extmbr" name="monix.tail.Iterant#scan">scan</a>, but this can suspend and evaluate
side effects in the <code>F[_]</code> context, thus allowing for
asynchronous data processing.</p><p>Similar to <a href="Iterant.html#foldLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):F[S]" class="extmbr" name="monix.tail.Iterant#foldLeftL">foldLeftL</a> and <a href="Iterant.html#foldWhileLeftEvalL[S](seed:F[S])(op:(S,A)=&gt;F[Either[S,S]])(implicitF:cats.effect.Sync[F]):F[S]" class="extmbr" name="monix.tail.Iterant#foldWhileLeftEvalL">foldWhileLeftEvalL</a>, but
emits the state on each step. Useful for modeling finite
state machines.</p><p>Example showing how state can be evolved and acted upon:</p><pre><span class="kw">sealed</span> <span class="kw">trait</span> State[+A] { <span class="kw">def</span> count: <span class="std">Int</span> }
<span class="kw">case</span> <span class="kw">object</span> Init <span class="kw">extends</span> State[<span class="std">Nothing</span>] { <span class="kw">def</span> count = <span class="num">0</span> }
<span class="kw">case</span> <span class="kw">class</span> Current[A](current: <span class="std">Option</span>[A], count: <span class="std">Int</span>)
  <span class="kw">extends</span> State[A]

<span class="kw">case</span> <span class="kw">class</span> Person(id: <span class="std">Int</span>, name: <span class="std">String</span>)

<span class="cmt">// Initial state</span>
<span class="kw">val</span> seed = Task.now(Init : State[Person])

<span class="kw">val</span> scanned = source.scanEval(seed) { (state, id) <span class="kw">=&gt;</span>
  requestPersonDetails(id).map { person <span class="kw">=&gt;</span>
    state <span class="kw">match</span> {
      <span class="kw">case</span> Init <span class="kw">=&gt;</span>
        Current(person, <span class="num">1</span>)
      <span class="kw">case</span> Current(_, count) <span class="kw">=&gt;</span>
        Current(person, count + <span class="num">1</span>)
    }
  }
}

scanned
  .takeWhile(_.count &lt; <span class="num">10</span>)
  .collect { <span class="kw">case</span> Current(a, _) <span class="kw">=&gt;</span> a }</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the function that evolves the current state</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that emits all intermediate states being
        resulted from applying the given function</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" class="extmbr" name="monix.tail.Iterant#scan">scan</a> for the version that does not require using <code>F[_]</code>
     in the provided operator</p></span></dd></dl></div>
    </li><li name="monix.tail.Iterant#scanMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scanMap[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F],implicitB:cats.Monoid[B]):monix.tail.Iterant[F,B]"></a><a id="scanMap[B]((A)⇒B)(Sync[F],Monoid[B]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#scanMap[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F],implicitB:cats.Monoid[B]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <span class="extype" name="monix.tail.Iterant.scanMap.B">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="B">B: <span class="extype" name="cats.Monoid">Monoid</span>[<span class="extype" name="monix.tail.Iterant.scanMap.B">B</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.scanMap.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" class="extype" name="cats">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" class="extype" name="cats">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><p>Equivalent with <a href="Iterant.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" class="extmbr" name="monix.tail.Iterant#scan">scan</a> applied with the given <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" class="extype" name="cats">cats.Monoid</a>, so given
our <code>f</code> mapping function returns a <code>B</code>, this law holds:</p><pre><span class="kw">val</span> B = implicitly[Monoid[B]]

stream.scanMap(f) <span class="kw">&lt;-</span>&gt; stream.scan(B.empty)(B.combine)</pre><p>Example:</p><pre><span class="cmt">// Yields 2, 6, 12, 20, 30, 42</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).scanMap(x <span class="kw">=&gt;</span> x * <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the mapping function applied to every incoming element of this <code>Iterant</code>
         before folding using <code>Monoid[B].combine</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new <code>Iterant</code> that emits all intermediate states being
        resulted from applying <code>Monoid[B].combine</code> function</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#skipSuspendL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="skipSuspendL(implicitF:cats.effect.Sync[F]):F[monix.tail.Iterant[F,A]]"></a><a id="skipSuspendL(Sync[F]):F[Iterant[F,A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#skipSuspendL(implicitF:cats.effect.Sync[F]):F[monix.tail.Iterant[F,A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">skipSuspendL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Skips over <a href="Iterant$$Suspend.html" class="extype" name="monix.tail.Iterant.Suspend">Iterant.Suspend</a> states, along with
<a href="" class="extype" name="monix.tail.Iterant.NextCursor">Iterant.NextCursor</a> and <a href="Iterant$$NextBatch.html" class="extype" name="monix.tail.Iterant.NextBatch">Iterant.NextBatch</a> states that
signal empty collections.</p><div class="fullcomment"><div class="comment cmt"><p>Skips over <a href="Iterant$$Suspend.html" class="extype" name="monix.tail.Iterant.Suspend">Iterant.Suspend</a> states, along with
<a href="" class="extype" name="monix.tail.Iterant.NextCursor">Iterant.NextCursor</a> and <a href="Iterant$$NextBatch.html" class="extype" name="monix.tail.Iterant.NextBatch">Iterant.NextBatch</a> states that
signal empty collections.</p><p>Will mirror the source, except that the emitted internal states
might be different. Can be used as an optimization if necessary.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant.NextCursor#stop" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="stop:F[Unit]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#stop:F[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">stop</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>
      </span>
      
      
    </li><li name="monix.tail.Iterant#sumL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sumL(implicitF:cats.effect.Sync[F],implicitA:Numeric[A]):F[A]"></a><a id="sumL(Sync[F],Numeric[A]):F[A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#sumL(implicitF:cats.effect.Sync[F],implicitA:Numeric[A]):F[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sumL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="A">A: <span class="extype" name="scala.Numeric">Numeric</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Given evidence that type <code>A</code> has a <code>scala.math.Numeric</code> implementation,
sums the stream of elements.</p><div class="fullcomment"><div class="comment cmt"><p>Given evidence that type <code>A</code> has a <code>scala.math.Numeric</code> implementation,
sums the stream of elements.</p><p>An alternative to <a href="Iterant.html#foldL(implicitF:cats.effect.Sync[F],implicitA:cats.Monoid[A]):F[A]" class="extmbr" name="monix.tail.Iterant#foldL">foldL</a> which does not require any imports and works
in cases <code>cats.Monoid</code> is not defined for values (e.g. <code>A = Char</code>)
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#switchIfEmpty" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="switchIfEmpty(backup:monix.tail.Iterant[F,A])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="switchIfEmpty(Iterant[F,A])(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#switchIfEmpty(backup:monix.tail.Iterant[F,A])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">switchIfEmpty</span><span class="params">(<span name="backup">backup: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">In case this Iterant is empty, switch to the given backup.</p><div class="fullcomment"><div class="comment cmt"><p>In case this Iterant is empty, switch to the given backup.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="monix.tail.Iterant#tail" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tail(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="tail(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#tail(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tail</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Drops the first element of the source iterant, emitting the rest.</p><div class="fullcomment"><div class="comment cmt"><p>Drops the first element of the source iterant, emitting the rest.</p><p>Example: </p><pre><span class="cmt">// Yields 2, 3, 4</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).tail</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a new iterant that upon evaluation will emit all
        elements of the source, except for the head</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#take" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="take(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="take(Int)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#take(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">take</span><span class="params">(<span name="n">n: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a new iterant that upon evaluation will select
the first <code>n</code> elements from the source and then stop,
in the order they are emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new iterant that upon evaluation will select
the first <code>n</code> elements from the source and then stop,
in the order they are emitted by the source.</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2, 3</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).take(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>is the number of elements to take from this iterant</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will emit
        only the first <code>n</code> elements of this iterant</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#takeEveryNth" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeEveryNth(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="takeEveryNth(Int)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#takeEveryNth(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeEveryNth</span><span class="params">(<span name="n">n: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Takes every n-th element, dropping intermediary elements
and returns a new iterant that emits those elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes every n-th element, dropping intermediary elements
and returns a new iterant that emits those elements.</p><p>Example: </p><pre><span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).takeEveryNth(<span class="num">2</span>)

<span class="cmt">// Yields 1, 2, 3, 4, 5, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).takeEveryNth(<span class="num">1</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>is the sequence number of an element to be taken (must be &gt; 0)</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will return only every n-th
        element of the source</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#takeLast" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeLast(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="takeLast(Int)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#takeLast(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeLast</span><span class="params">(<span name="n">n: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a new iterable that only emits the last <code>n</code> elements
emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new iterable that only emits the last <code>n</code> elements
emitted by the source.</p><p>In case the source triggers an error, then the underlying buffer
gets dropped and the error gets emitted immediately.</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2, 3</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).take(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>is the number of elements to take from the end of the
       stream.</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will emit the
        last <code>n</code> elements of the source</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#takeWhile" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="takeWhile((A)⇒Boolean)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#takeWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Takes longest prefix of elements that satisfy the given predicate
and returns a new iterant that emits those elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes longest prefix of elements that satisfy the given predicate
and returns a new iterant that emits those elements.</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2, 3</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).takeWhile(_ &lt; <span class="num">4</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the function that tests each element, stopping
         the streaming on the first <code>false</code> result</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will all
        elements of the source for as long as the given predicate
        returns <code>true</code>, stopping upon the first <code>false</code> result</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#takeWhileWithIndex" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeWhileWithIndex(p:(A,Long)=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="takeWhileWithIndex((A,Long)⇒Boolean)(Sync[F]):Iterant[F,A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#takeWhileWithIndex(p:(A,Long)=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeWhileWithIndex</span><span class="params">(<span name="p">p: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <a href="http://www.scala-lang.org/api/2.12.4/scala/Long.html#scala.Long" class="extype" name="scala.Long">Long</a>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Takes longest prefix of elements zipped with their indices that satisfy the given predicate
and returns a new iterant that emits those elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes longest prefix of elements zipped with their indices that satisfy the given predicate
and returns a new iterant that emits those elements.</p><p>Example: </p><pre><span class="cmt">// Yields 1, 2</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).takeWhileWithIndex((_, idx) <span class="kw">=&gt;</span> idx != <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the function that tests each element, stopping
         the streaming on the first <code>false</code> result</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will all
        elements of the source for as long as the given predicate
        returns <code>true</code>, stopping upon the first <code>false</code> result</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#toListL" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toListL(implicitF:cats.effect.Sync[F]):F[List[A]]"></a><a id="toListL(Sync[F]):F[List[A]]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#toListL(implicitF:cats.effect.Sync[F]):F[List[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toListL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Aggregates all elements in a <code>List</code> and preserves order.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregates all elements in a <code>List</code> and preserves order.</p><p>Example: </p><pre><span class="cmt">// Yields List(1, 2, 3, 4)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).toListL</pre><p>Note that this operation is dangerous, since if the iterant is
infinite then this operation is non-terminating, the process
probably blowing up with an out of memory error sooner or later.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#toReactivePublisher" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toReactivePublisher(implicitF:cats.effect.Effect[F],implicitec:monix.execution.Scheduler):org.reactivestreams.Publisher[A]"></a><a id="toReactivePublisher(Effect[F],Scheduler):Publisher[A]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#toReactivePublisher(implicitF:cats.effect.Effect[F],implicitec:monix.execution.Scheduler):org.reactivestreams.Publisher[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toReactivePublisher</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Effect">Effect</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>, <span name="ec">ec: <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a></span>)</span><span class="result">: <span class="extype" name="org.reactivestreams.Publisher">Publisher</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Converts this <code>Iterant</code> into an <code>org.reactivestreams.Publisher</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this <code>Iterant</code> into an <code>org.reactivestreams.Publisher</code>.</p><p>Meant for interoperability with other Reactive Streams
implementations. Also useful because it turns the <code>Iterant</code>
into another data type with a push-based communication protocol
with back-pressure.</p><p>Usage sample:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.rstreams.SingleAssignmentSubscription
<span class="kw">import</span> org.reactivestreams.{Publisher, Subscriber, Subscription}

<span class="kw">def</span> sum(source: Publisher[<span class="std">Int</span>], requestSize: <span class="std">Int</span>): Task[<span class="std">Long</span>] =
  Task.create { (_, cb) <span class="kw">=&gt;</span>
    <span class="kw">val</span> sub = SingleAssignmentSubscription()

    source.subscribe(<span class="kw">new</span> Subscriber[<span class="std">Int</span>] {
      <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> requested = <span class="num">0</span>L
      <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> sum = <span class="num">0</span>L

      <span class="kw">def</span> onSubscribe(s: Subscription): <span class="std">Unit</span> = {
        sub := s
        requested = requestSize
        s.request(requestSize)
      }

      <span class="kw">def</span> onNext(t: <span class="std">Int</span>): <span class="std">Unit</span> = {
        sum += t
        <span class="kw">if</span> (requestSize != <span class="std">Long</span>.MaxValue) requested -= <span class="num">1</span>

        <span class="kw">if</span> (requested &lt;= <span class="num">0</span>) {
          requested = requestSize
          sub.request(request)
        }
      }

      <span class="kw">def</span> onError(t: Throwable): <span class="std">Unit</span> =
        cb.onError(t)
      <span class="kw">def</span> onComplete(): <span class="std">Unit</span> =
        cb.onSuccess(sum)
    })

    <span class="cmt">// Cancelable that can be used by Task</span>
    sub
  }

<span class="kw">val</span> pub = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).toReactivePublisher

<span class="cmt">// Yields 10</span>
sum(pub, requestSize = <span class="num">128</span>)</pre><p>See the <a href="http://www.reactive-streams.org/" target="_blank">Reactive Streams</a>
for details.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#unsafeFlatMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsafeFlatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="unsafeFlatMap[B]((A)⇒Iterant[F,B])(Sync[F]):Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#unsafeFlatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsafeFlatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>) ⇒ <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.unsafeFlatMap.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.unsafeFlatMap.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Applies the function to the elements of the source and
concatenates the results.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the function to the elements of the source and
concatenates the results.</p><p>This variant of <a href="Iterant.html#flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" class="extmbr" name="monix.tail.Iterant#flatMap">flatMap</a> is not referentially transparent,
because it tries to apply function <code>f</code> immediately, in case the
<code>Iterant</code> is in a <code>NextCursor</code> or <code>NextBatch</code> state.</p><p>To be used for optimizations, but keep in mind it's unsafe, as
its application isn't referentially transparent.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function mapping elements from the source to
       iterants</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#upcast" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="upcast[B&gt;:A]:monix.tail.Iterant[F,B]"></a><a id="upcast[B&gt;:A]:Iterant[F,B]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#upcast[B&gt;:A]:monix.tail.Iterant[F,B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">upcast</span><span class="tparams">[<span name="B">B &gt;: <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span></span>]</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.upcast.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Explicit covariance operator.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit covariance operator.</p><p>The <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a> type isn't covariant in type param <code>A</code>, because
covariance doesn't play well with a higher-kinded type like
<code>F[_]</code>.  So in case you have an <code>Iterant[F, A]</code>, but need an
<code>Iterant[F, B]</code>, knowing that <code>A extends B</code>, then you can do an
<code>upcast</code>.</p><p>Example: </p><pre><span class="kw">val</span> source: Iterant[Task, <span class="std">List</span>[<span class="std">Int</span>]] = ???

<span class="cmt">// This will trigger an error because of the invariance:</span>
<span class="kw">val</span> sequences: Iterant[Task, <span class="std">Seq</span>[<span class="std">Int</span>]] = source

<span class="cmt">// But this will work just fine:</span>
<span class="kw">val</span> sequences: Iterant[Task, <span class="std">Seq</span>[<span class="std">Int</span>]] = source.upcast[<span class="std">Seq</span>[<span class="std">Int</span>]]</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/Long.html#scala.Long" class="extype" name="scala.Long">Long</a></span>, <span name="arg1">arg1: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/Long.html#scala.Long" class="extype" name="scala.Long">Long</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="monix.tail.Iterant#zip" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zip[B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,B)]"></a><a id="zip[B](Iterant[F,B])(Sync[F]):Iterant[F,(A,B)]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#zip[B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,B)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.zip.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <span class="extype" name="monix.tail.Iterant.zip.B">B</span>)]</span>
      </span>
      
      <p class="shortcomment cmt">Lazily zip two iterants together.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily zip two iterants together.</p><p>The length of the result will be the shorter of the two
arguments.</p><p>Example: </p><pre><span class="kw">val</span> lh = Iterant[Task].of(<span class="num">11</span>, <span class="num">12</span>, <span class="num">13</span>, <span class="num">14</span>)
<span class="kw">val</span> rh = Iterant[Task].of(<span class="num">21</span>, <span class="num">22</span>, <span class="num">23</span>, <span class="num">24</span>, <span class="num">25</span>)

<span class="cmt">// Yields (11, 21), (12, 22), (13, 23), (14, 24)</span>
lh.zip(rh)</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to zip the source with (the
       right hand side)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#zipMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zipMap[B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,C]"></a><a id="zipMap[B,C](Iterant[F,B])((A,B)⇒C)(Sync[F]):Iterant[F,C]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#zipMap[B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,C]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zipMap</span><span class="tparams">[<span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.zipMap.B">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <span class="extype" name="monix.tail.Iterant.zipMap.B">B</span>) ⇒ <span class="extype" name="monix.tail.Iterant.zipMap.C">C</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.zipMap.C">C</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Lazily zip two iterants together, using the given function <code>f</code> to
produce output values.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily zip two iterants together, using the given function <code>f</code> to
produce output values.</p><p>The length of the result will be the shorter of the two
arguments.</p><p>Example: </p><pre><span class="kw">val</span> lh = Iterant[Task].of(<span class="num">11</span>, <span class="num">12</span>, <span class="num">13</span>, <span class="num">14</span>)
<span class="kw">val</span> rh = Iterant[Task].of(<span class="num">21</span>, <span class="num">22</span>, <span class="num">23</span>, <span class="num">24</span>, <span class="num">25</span>)

<span class="cmt">// Yields 32, 34, 36, 38</span>
lh.zipMap(rh) { (a, b) <span class="kw">=&gt;</span> a + b }</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to zip the source with (the
       right hand side)</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the mapping function to transform the zipped
       <code>(A, B)</code> elements</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li><li name="monix.tail.Iterant#zipWithIndex" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zipWithIndex(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,Long)]"></a><a id="zipWithIndex(Sync[F]):Iterant[F,(A,Long)]"></a>
      <span class="permalink">
      <a href="../../monix/tail/Iterant$$NextCursor.html#zipWithIndex(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,Long)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zipWithIndex</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Sync">Sync</span>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, (<span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>, <a href="http://www.scala-lang.org/api/2.12.4/scala/Long.html#scala.Long" class="extype" name="scala.Long">Long</a>)]</span>
      </span>
      
      <p class="shortcomment cmt">Zips the emitted elements of the source with their indices.</p><div class="fullcomment"><div class="comment cmt"><p>Zips the emitted elements of the source with their indices.</p><p>The length of the result will be the same as the source.</p><p>Example: </p><pre><span class="kw">val</span> source = Iterant[Task].of(<span class="lit">"Sunday"</span>, <span class="lit">"Monday"</span>, <span class="lit">"Tuesday"</span>, <span class="lit">"Wednesday"</span>)

<span class="cmt">// Yields ("Sunday", 0), ("Monday", 1), ("Tuesday", 2), ("Wednesday", 3)</span>
source.zipWithIndex</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a></dd></dl></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="monix.tail.Iterant">
              <h3>Inherited from <a href="Iterant.html" class="extype" name="monix.tail.Iterant">Iterant</a>[<span class="extype" name="monix.tail.Iterant.NextCursor.F">F</span>, <span class="extype" name="monix.tail.Iterant.NextCursor.A">A</span>]</h3>
            </div><div class="parent" name="scala.Serializable">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></h3>
            </div><div class="parent" name="java.io.Serializable">
              <h3>Inherited from <span class="extype" name="java.io.Serializable">Serializable</span></h3>
            </div><div class="parent" name="scala.Product">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.4/scala/Product.html#scala.Product" class="extype" name="scala.Product">Product</a></h3>
            </div><div class="parent" name="scala.Equals">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.4/scala/Equals.html#scala.Equals" class="extype" name="scala.Equals">Equals</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
