<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>Monix 3.0.0-RC1 - monix.eval.Task</title>
          <meta name="description" content="Monix 3.0.0 - RC1 - monix.eval.Task" />
          <meta name="keywords" content="Monix 3.0.0 RC1 monix.eval.Task" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../lib/index.js"></script>
      <script type="text/javascript" src="../../index.js"></script>
      <script type="text/javascript" src="../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">Monix<span id="doc-version">3.0.0-RC1</span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">root</span></a>
      </span>
      
      <p class="shortcomment cmt"><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><div class="fullcomment"><div class="comment cmt"><p><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><p>This is the API documentation for the <a href="https://monix.io" target="_blank">Monix</a> library.</p><h4>Package Overview</h4><p><b><a href="../execution/index.html" class="extype" name="monix.execution">monix.execution</a></b> exposes lower level primitives for dealing
with asynchronous execution:</p><ul><li><a href="../execution/atomic/index.html" class="extype" name="monix.execution.atomic">monix.execution.atomic</a> exposes the <code>Atomic</code> types, as alternative
   to <code>java.util.concurrent.atomic</code></li><li><a href="../execution/cancelables/index.html" class="extype" name="monix.execution.cancelables">monix.execution.cancelables</a> contains several
   useful <a href="../execution/Cancelable.html" class="extype" name="monix.execution.Cancelable">Cancelable</a> implementations</li><li><a href="../execution/schedulers/index.html" class="extype" name="monix.execution.schedulers">monix.execution.schedulers</a> contains several
   useful <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a> implementations</li><li><a href="../execution/rstreams/index.html" class="extype" name="monix.execution.rstreams">monix.execution.rstreams</a> contains helpers for dealing
   with the <a href="http://www.reactive-streams.org" target="_blank">Reactive Streams</a> specification</li><li><a href="../execution/misc/index.html" class="extype" name="monix.execution.misc">monix.execution.misc</a> provides miscellaneous primitives
   useful for dealing with concurrency</li><li><a href="../execution/exceptions/index.html" class="extype" name="monix.execution.exceptions">monix.execution.exceptions</a> groups some exceptions thrown by
   the implementation</li></ul><p><b><a href="index.html" class="extype" name="monix.eval">monix.eval</a></b> is for dealing with evaluation of results, thus exposing
<a href="Task.html" class="extype" name="monix.eval.Task">Task</a> and <a href="Coeval.html" class="extype" name="monix.eval.Coeval">Coeval</a>.</p><p><b><a href="../reactive/index.html" class="extype" name="monix.reactive">monix.reactive</a></b> exposes the <code>Observable</code> pattern:</p><ul><li><a href="../reactive/observables/index.html" class="extype" name="monix.reactive.observables">monix.reactive.observables</a> groups reusable <code>Observable</code> implementations</li><li><a href="../reactive/observers/index.html" class="extype" name="monix.reactive.observers">monix.reactive.observers</a> groups reusable <a href="../reactive/Observer.html" class="extype" name="monix.reactive.Observer">Observer</a>
   implementations</li><li><a href="../reactive/subjects/index.html" class="extype" name="monix.reactive.subjects">monix.reactive.subjects</a> exposes <a href="../reactive/subjects/Subject.html" class="extype" name="monix.reactive.subjects.Subject">Subject</a>
   and <a href="../reactive/subjects/ConcurrentSubject.html" class="extype" name="monix.reactive.subjects.ConcurrentSubject">ConcurrentSubject</a>,
   which are implementations of hot observables that function both as input and output</li></ul></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.monix" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="monix"></a><a id="monix:monix"></a>
      <span class="permalink">
      <a href="index.html#monix" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">monix</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="monix.eval" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eval"></a><a id="eval:eval"></a>
      <span class="permalink">
      <a href="../monix/index.html#eval" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">eval</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="monix">monix</a></dd></dl></div>
    </li><li name="monix.eval.instances" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="instances"></a><a id="instances:instances"></a>
      <span class="permalink">
      <a href="../../monix/eval/index.html#instances" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="instances/index.html"><span class="name">instances</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="monix.eval">eval</a></dd></dl></div>
    </li><li class="current-entities indented2">
                        <a class="object" href="Callback$.html" title=""></a>
                        <a class="class" href="Callback.html" title="Represents a callback that should be called asynchronously with the result of a computation."></a>
                        <a href="Callback.html" title="Represents a callback that should be called asynchronously with the result of a computation.">Callback</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Coeval$.html" title="Coeval builders."></a>
                        <a class="class" href="Coeval.html" title="Coeval represents lazy computations that can execute synchronously."></a>
                        <a href="Coeval.html" title="Coeval represents lazy computations that can execute synchronously.">Coeval</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Fiber$.html" title=""></a>
                        <a class="trait" href="Fiber.html" title="Fiber represents the (pure) result of a Task being started concurrently and that can be either joined or cancelled."></a>
                        <a href="Fiber.html" title="Fiber represents the (pure) result of a Task being started concurrently and that can be either joined or cancelled.">Fiber</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="MVar$.html" title="Builders for MVar"></a>
                        <a class="class" href="MVar.html" title="A mutable location, that is either empty or contains a value of type A."></a>
                        <a href="MVar.html" title="A mutable location, that is either empty or contains a value of type A.">MVar</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="" title="Builders for Task."></a>
                        <a class="class" href="Task.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects."></a>
                        <a href="Task.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects.">Task</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="TaskApp.html" title="Safe App type that runs a Task action."></a>
                        <a href="TaskApp.html" title="Safe App type that runs a Task action.">TaskApp</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="TaskCircuitBreaker$.html" title=""></a>
                        <a class="class" href="TaskCircuitBreaker.html" title="The TaskCircuitBreaker is used to provide stability and prevent cascading failures in distributed systems."></a>
                        <a href="TaskCircuitBreaker.html" title="The TaskCircuitBreaker is used to provide stability and prevent cascading failures in distributed systems.">TaskCircuitBreaker</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="TaskLocal$.html" title="Builders for TaskLocal"></a>
                        <a class="class" href="TaskLocal.html" title="A TaskLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the Task data type."></a>
                        <a href="TaskLocal.html" title="A TaskLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the Task data type.">TaskLocal</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="TaskSemaphore$.html" title=""></a>
                        <a class="class" href="TaskSemaphore.html" title="The TaskSemaphore is an asynchronous semaphore implementation that limits the parallelism on task execution."></a>
                        <a href="TaskSemaphore.html" title="The TaskSemaphore is an asynchronous semaphore implementation that limits the parallelism on task execution.">TaskSemaphore</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="object value">
      <div id="definition">
        <a href="Task.html" title="See companion class"><div class="big-circle object-companion-class">o</div></a>
        <p id="owner"><a href="../index.html" class="extype" name="monix">monix</a>.<a href="index.html" class="extype" name="monix.eval">eval</a></p>
        <h1><a href="Task.html" title="See companion class">Task</a><span class="permalink">
      <a href="../../monix/eval/Task$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"><div>
            Companion <a href="Task.html" title="See companion class">class Task</a>
          </div></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">Task</span><span class="result"> extends <span class="extype" name="monix.eval.TaskInstancesLevel1">TaskInstancesLevel1</span> with <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Builders for <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>.</p></div><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/monix/monix/tree/v3.0.0-RC1/monix-eval/shared/src/main/scala/monix/eval/Task.scala" target="_blank">Task.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a>, <span class="extype" name="java.io.Serializable">Serializable</span>, <span class="extype" name="monix.eval.TaskInstancesLevel1">TaskInstancesLevel1</span>, <span class="extype" name="monix.eval.TaskInstancesLevel0">TaskInstancesLevel0</span>, <span class="extype" name="monix.eval.TaskParallelNewtype">TaskParallelNewtype</span>, <span class="extype" name="monix.eval.TaskTimers">TaskTimers</span>, <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a>, <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="monix.eval.Task"><span>Task</span></li><li class="in" name="scala.Serializable"><span>Serializable</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="monix.eval.TaskInstancesLevel1"><span>TaskInstancesLevel1</span></li><li class="in" name="monix.eval.TaskInstancesLevel0"><span>TaskInstancesLevel0</span></li><li class="in" name="monix.eval.TaskParallelNewtype"><span>TaskParallelNewtype</span></li><li class="in" name="monix.eval.TaskTimers"><span>TaskTimers</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="monix.eval.Task.Context" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ContextextendsProductwithSerializable"></a><a id="Context:Context"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#ContextextendsProductwithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="The Context under which Task is supposed to be executed." href="Task$$Context.html"><span class="name">Context</span></a><span class="params">(<span name="scheduler">scheduler: <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a></span>, <span name="options">options: <a href="Task$$Options.html" class="extype" name="monix.eval.Task.Options">Options</a></span>, <span name="connection">connection: <a href="../execution/cancelables/StackedCancelable.html" class="extype" name="monix.execution.cancelables.StackedCancelable">StackedCancelable</a></span>, <span name="frameRef">frameRef: <a href="Task$$FrameIndexRef.html" class="extype" name="monix.eval.Task.FrameIndexRef">FrameIndexRef</a></span>)</span><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.4/scala/Product.html#scala.Product" class="extype" name="scala.Product">Product</a> with <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      
      <p class="shortcomment cmt">The <code>Context</code> under which <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> is supposed to be executed.</p><div class="fullcomment"><div class="comment cmt"><p>The <code>Context</code> under which <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> is supposed to be executed.</p><p>This definition is of interest only when creating
tasks with <a href="#unsafeCreate[A](register:(monix.eval.Task.Context,monix.eval.Callback[A])=&gt;Unit):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#unsafeCreate">Task.unsafeCreate</a>, which exposes internals and
is considered unsafe to use.
</p></div><dl class="paramcmts block"><dt class="param">scheduler</dt><dd class="cmt"><p>is the <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>
       in charge of evaluation on <code>runAsync</code>.</p></dd><dt class="param">options</dt><dd class="cmt"><p>is a set of options for customizing the task's
       behavior upon evaluation.</p></dd><dt class="param">connection</dt><dd class="cmt"><p>is the
       <a href="../execution/cancelables/StackedCancelable.html" class="extype" name="monix.execution.cancelables.StackedCancelable">StackedCancelable</a>
       that handles the cancellation on <code>runAsync</code></p></dd><dt class="param">frameRef</dt><dd class="cmt"><p>is a thread-local counter that keeps track
       of the current frame index of the run-loop. The run-loop
       is supposed to force an asynchronous boundary upon
       reaching a certain threshold, when the task is evaluated
       with
       <a href="../execution/ExecutionModel$$BatchedExecution.html" class="extype" name="monix.execution.ExecutionModel.BatchedExecution">monix.execution.ExecutionModel.BatchedExecution</a>.
       And this <code>frameIndexRef</code> should be reset whenever a real
       asynchronous boundary happens.
       See the description of <a href="Task$$FrameIndexRef.html" class="extype" name="monix.eval.Task.FrameIndexRef">FrameIndexRef</a>.</p></dd></dl></div>
    </li><li name="monix.eval.Task.DeprecatedExtensions" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="DeprecatedExtensions[A]extendsAnyVal"></a><a id="DeprecatedExtensions[A]:DeprecatedExtensions[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#DeprecatedExtensions[A]extendsAnyVal" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="" href="Task$$DeprecatedExtensions.html"><span class="name">DeprecatedExtensions</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyVal" class="extype" name="scala.collection.immutable.List">AnyVal</a></span>
      </span>
      
      
    </li><li name="monix.eval.Task.FrameIndex" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FrameIndex=Int"></a><a id="FrameIndex:FrameIndex"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#FrameIndex=Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">FrameIndex</span><span class="result alias"> = <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>
      </span>
      
      <p class="shortcomment cmt">A run-loop frame index is a number representing the current run-loop
cycle, being incremented whenever a <code>flatMap</code> evaluation happens.</p><div class="fullcomment"><div class="comment cmt"><p>A run-loop frame index is a number representing the current run-loop
cycle, being incremented whenever a <code>flatMap</code> evaluation happens.</p><p>It gets used for automatically forcing asynchronous boundaries, according to the
<a href="../execution/ExecutionModel.html" class="extype" name="monix.execution.ExecutionModel">ExecutionModel</a>
injected by the <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a> when
the task gets evaluated with <code>runAsync</code>.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="Task$$FrameIndexRef.html" class="extype" name="monix.eval.Task.FrameIndexRef">FrameIndexRef</a></p></span></dd></dl></div>
    </li><li name="monix.eval.Task.FrameIndexRef" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="FrameIndexRefextendsAnyRef"></a><a id="FrameIndexRef:FrameIndexRef"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#FrameIndexRefextendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A reference that boxes a FrameIndex possibly using a thread-local." href="Task$$FrameIndexRef.html"><span class="name">FrameIndexRef</span></a><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></span>
      </span>
      
      <p class="shortcomment cmt">A reference that boxes a <a href="#FrameIndex=Int" class="extmbr" name="monix.eval.Task.FrameIndex">FrameIndex</a> possibly using a thread-local.</p><div class="fullcomment"><div class="comment cmt"><p>A reference that boxes a <a href="#FrameIndex=Int" class="extmbr" name="monix.eval.Task.FrameIndex">FrameIndex</a> possibly using a thread-local.</p><p>This definition is of interest only when creating
tasks with <a href="#unsafeCreate[A](register:(monix.eval.Task.Context,monix.eval.Callback[A])=&gt;Unit):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#unsafeCreate">Task.unsafeCreate</a>, which exposes internals and
is considered unsafe to use.</p><p>In case the <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> is executed with
<a href="../execution/ExecutionModel$$BatchedExecution.html" class="extype" name="monix.execution.ExecutionModel.BatchedExecution">BatchedExecution</a>,
this class boxes a <a href="#FrameIndex=Int" class="extmbr" name="monix.eval.Task.FrameIndex">FrameIndex</a> in order to transport it over
light async boundaries, possibly using a
<a href="../execution/misc/ThreadLocal.html" class="extype" name="monix.execution.misc.ThreadLocal">ThreadLocal</a>, since this
index is not supposed to survive when threads get forked.</p><p>The <a href="#FrameIndex=Int" class="extmbr" name="monix.eval.Task.FrameIndex">FrameIndex</a> is a counter that increments whenever a
<code>flatMap</code> operation is evaluated. And with <code>BatchedExecution</code>,
whenever that counter exceeds the specified threshold, an
asynchronous boundary is automatically inserted. However this
capability doesn't blend well with light asynchronous
boundaries, for example <code>Async</code> tasks that never fork logical threads or
<a href="../execution/schedulers/TrampolinedRunnable.html" class="extype" name="monix.execution.schedulers.TrampolinedRunnable">TrampolinedRunnable</a>
instances executed by capable schedulers. This is why
<a href="Task$$FrameIndexRef.html" class="extype" name="monix.eval.Task.FrameIndexRef">FrameIndexRef</a> is part of the <a href="Task$$Context.html" class="extype" name="monix.eval.Task.Context">Context</a> of execution for
<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>, available for asynchronous tasks that get created with
<a href="#unsafeCreate[A](register:(monix.eval.Task.Context,monix.eval.Callback[A])=&gt;Unit):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#unsafeCreate">Task.unsafeCreate</a>.</p><p>Note that in case the execution model is not
<a href="../execution/ExecutionModel$$BatchedExecution.html" class="extype" name="monix.execution.ExecutionModel.BatchedExecution">BatchedExecution</a>
then this reference is just a dummy, since there's no point in
keeping a counter around, plus setting and fetching from a
<code>ThreadLocal</code> can be quite expensive.
</p></div></div>
    </li><li name="monix.eval.Task.Options" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OptionsextendsProductwithSerializable"></a><a id="Options:Options"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#OptionsextendsProductwithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="Set of options for customizing the task's behavior." href="Task$$Options.html"><span class="name">Options</span></a><span class="params">(<span name="autoCancelableRunLoops">autoCancelableRunLoops: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>, <span name="localContextPropagation">localContextPropagation: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.4/scala/Product.html#scala.Product" class="extype" name="scala.Product">Product</a> with <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      
      <p class="shortcomment cmt">Set of options for customizing the task's behavior.</p><div class="fullcomment"><div class="comment cmt"><p>Set of options for customizing the task's behavior.</p><p>See <a href="#defaultOptions:monix.eval.Task.Options" class="extmbr" name="monix.eval.Task#defaultOptions">Task.defaultOptions</a> for the default <code>Options</code> instance
used by <a href="Task.html#runAsync(implicits:monix.execution.Scheduler):monix.execution.CancelableFuture[A]" class="extmbr" name="monix.eval.Task#runAsync">.runAsync</a>.
</p></div><dl class="paramcmts block"><dt class="param">autoCancelableRunLoops</dt><dd class="cmt"><p>should be set to <code>true</code> in
       case you want <code>flatMap</code> driven loops to be
       auto-cancelable. Defaults to <code>false</code>.</p></dd><dt class="param">localContextPropagation</dt><dd class="cmt"><p>should be set to <code>true</code> in
       case you want the <a href="../execution/misc/Local.html" class="extype" name="monix.execution.misc.Local">Local</a>
       variables to be propagated on async boundaries.
       Defaults to <code>false</code>.</p></dd></dl></div>
    </li><li name="monix.eval.TaskParallelNewtype.Par" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Par[+A]=TaskParallelNewtype.this.Par.Type[A]"></a><a id="Par[+A]:Par[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#Par[+A]=TaskParallelNewtype.this.Par.Type[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Par</span><span class="tparams">[<span name="A">+A</span>]</span><span class="result alias"> = <span class="extype" name="monix.execution.internal.Newtype1.Type">TaskParallelNewtype.Par.Type</span>[<span class="extype" name="monix.eval.TaskParallelNewtype.Par.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Newtype encoding for an <code>Task</code> datatype that has a <a href="http://typelevel.org/cats/api/cats/Applicative.html" class="extype" name="cats.Applicative">cats.Applicative</a>
capable of doing parallel processing in <code>ap</code> and <code>map2</code>, needed
for implementing <a href="http://typelevel.org/cats/api/cats/Parallel.html" class="extype" name="cats.Parallel">cats.Parallel</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Newtype encoding for an <code>Task</code> datatype that has a <a href="http://typelevel.org/cats/api/cats/Applicative.html" class="extype" name="cats.Applicative">cats.Applicative</a>
capable of doing parallel processing in <code>ap</code> and <code>map2</code>, needed
for implementing <a href="http://typelevel.org/cats/api/cats/Parallel.html" class="extype" name="cats.Parallel">cats.Parallel</a>.</p><p>Helpers are provided for converting back and forth in <code>Par.apply</code>
for wrapping any <code>Task</code> value and <code>Par.unwrap</code> for unwrapping.</p><p>The encoding is based on the &quot;newtypes&quot; project by
Alexander Konovalov, chosen because it's devoid of boxing issues and
a good choice until opaque types will land in Scala.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskParallelNewtype</dd></dl></div>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="monix.eval.Task#apply" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply[A](f:=&gt;A):monix.eval.Task[A]"></a><a id="apply[A](⇒A):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#apply[A](f:=&gt;A):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: ⇒ <span class="extype" name="monix.eval.Task.apply.A">A</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.apply.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a new task that, when executed, will emit the result of
the given function, executed asynchronously.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that, when executed, will emit the result of
the given function, executed asynchronously.</p><p>This operation is the equivalent of:</p><pre>Task.eval(f).executeAsync</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the callback to execute asynchronously</p></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="monix.eval.Task#async" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="async[A](register:(monix.execution.Scheduler,monix.eval.Callback[A])=&gt;monix.execution.Cancelable):monix.eval.Task[A]"></a><a id="async[A]((Scheduler,Callback[A])⇒Cancelable):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#async[A](register:(monix.execution.Scheduler,monix.eval.Callback[A])=&gt;monix.execution.Cancelable):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">async</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="register">register: (<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>, <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>[<span class="extype" name="monix.eval.Task.async.A">A</span>]) ⇒ <a href="../execution/Cancelable.html" class="extype" name="monix.execution.Cancelable">Cancelable</a></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.async.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Create a <code>Task</code> from an
        asynchronous computation, which takes the form of a
        function with which we can register a callback.</p><div class="fullcomment"><div class="comment cmt"><p>Create a <code>Task</code> from an
        asynchronous computation, which takes the form of a
        function with which we can register a callback.</p><p>        This can be used to translate from a callback-based API to
        a straightforward monadic version.</p><p>Alias for <a href="#create[A](register:(monix.execution.Scheduler,monix.eval.Callback[A])=&gt;monix.execution.Cancelable):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#create">Task.create</a>.
</p></div><dl class="paramcmts block"><dt class="param">register</dt><dd class="cmt"><p>is a function that will be called when
        this <code>Task</code> is executed, receiving a callback as a
        parameter, a callback that the user is supposed to call in
        order to signal the desired outcome of this <code>Task</code>.</p></dd></dl></div>
    </li><li name="monix.eval.TaskInstancesLevel1#catsAsync" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="catsAsync:monix.eval.instances.CatsConcurrentForTask"></a><a id="catsAsync:CatsConcurrentForTask"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#catsAsync:monix.eval.instances.CatsConcurrentForTask" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">catsAsync</span><span class="result">: <a href="instances/CatsConcurrentForTask.html" class="extype" name="monix.eval.instances.CatsConcurrentForTask">CatsConcurrentForTask</a></span>
      </span>
      
      <p class="shortcomment cmt">Global instance for <code>cats.effect.Async</code> and for <code>cats.effect.Concurrent</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Global instance for <code>cats.effect.Async</code> and for <code>cats.effect.Concurrent</code>.</p><p>Implied are also <code>cats.CoflatMap</code>, <code>cats.Applicative</code>, <code>cats.Monad</code>,
<code>cats.MonadError</code> and <code>cats.effect.Sync</code>.</p><p>As trivia, it's named &quot;catsAsync&quot; and not &quot;catsConcurrent&quot; because
it represents the <code>cats.effect.Async</code> lineage, up until
<code>cats.effect.Effect</code>, which imposes extra restrictions, in our case
the need for a <code>Scheduler</code> to be in scope (see <a href="#catsEffect(implicits:monix.execution.Scheduler):monix.eval.instances.CatsConcurrentEffectForTask" class="extmbr" name="monix.eval.Task#catsEffect">Task.catsEffect</a>).
So by naming the lineage, not the concrete sub-type implemented, we avoid
breaking compatibility whenever a new type class (that we can implement)
gets added into Cats.</p><p>Seek more info about Cats, the standard library for FP, at:</p><ul><li><a href="https://typelevel.org/cats/" target="_blank">typelevel/cats</a></li><li><a href="https://github.com/typelevel/cats-effect" target="_blank">typelevel/cats-effect</a>
</li></ul></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskInstancesLevel1</dd></dl></div>
    </li><li name="monix.eval.TaskInstancesLevel0#catsEffect" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="catsEffect(implicits:monix.execution.Scheduler):monix.eval.instances.CatsConcurrentEffectForTask"></a><a id="catsEffect(Scheduler):CatsConcurrentEffectForTask"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#catsEffect(implicits:monix.execution.Scheduler):monix.eval.instances.CatsConcurrentEffectForTask" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">catsEffect</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="instances/CatsConcurrentEffectForTask.html" class="extype" name="monix.eval.instances.CatsConcurrentEffectForTask">CatsConcurrentEffectForTask</a></span>
      </span>
      
      <p class="shortcomment cmt">Global instance for <code>cats.effect.Effect</code> and for
<code>cats.effect.ConcurrentEffect</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Global instance for <code>cats.effect.Effect</code> and for
<code>cats.effect.ConcurrentEffect</code>.</p><p>Implied are <code>cats.CoflatMap</code>, <code>cats.Applicative</code>, <code>cats.Monad</code>,
<code>cats.MonadError</code>, <code>cats.effect.Sync</code> and <code>cats.effect.Async</code>.</p><p>Note this is different from
<a href="#catsAsync:monix.eval.instances.CatsConcurrentForTask" class="extmbr" name="monix.eval.Task#catsAsync">Task.catsAsync</a> because we need an
implicit <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a> in scope in
order to trigger the execution of a <code>Task</code>. It's also lower
priority in order to not trigger conflicts, because
<code>Effect &lt;: Async</code> and <code>ConcurrentEffect &lt;: Concurrent with Effect</code>.</p><p>As trivia, it's named &quot;catsEffect&quot; and not &quot;catsConcurrentEffect&quot;
because it represents the <code>cats.effect.Effect</code> lineage, as in the
minimum that this value will support in the future. So by naming the
lineage, not the concrete sub-type implemented, we avoid breaking
compatibility whenever a new type class (that we can implement)
gets added into Cats.</p><p>Seek more info about Cats, the standard library for FP, at:</p><ul><li><a href="https://typelevel.org/cats/" target="_blank">typelevel/cats</a></li><li><a href="https://github.com/typelevel/cats-effect" target="_blank">typelevel/cats-effect</a>
</li></ul></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is a <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a> that needs
       to be available in scope</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskInstancesLevel0</dd></dl></div>
    </li><li name="monix.eval.TaskInstancesLevel1#catsMonoid" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="catsMonoid[A](implicitA:cats.Monoid[A]):cats.Monoid[monix.eval.Task[A]]"></a><a id="catsMonoid[A](Monoid[A]):Monoid[Task[A]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#catsMonoid[A](implicitA:cats.Monoid[A]):cats.Monoid[monix.eval.Task[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">catsMonoid</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span class="extype" name="cats.Monoid">Monoid</span>[<span class="extype" name="monix.eval.TaskInstancesLevel1.catsMonoid.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="cats.Monoid">Monoid</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.TaskInstancesLevel1.catsMonoid.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given an <code>A</code> type that has a <code>cats.Monoid[A]</code> implementation,
then this provides the evidence that <code>Task[A]</code> also has
a <code>Monoid[Task[A]]</code> implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Given an <code>A</code> type that has a <code>cats.Monoid[A]</code> implementation,
then this provides the evidence that <code>Task[A]</code> also has
a <code>Monoid[Task[A]]</code> implementation.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskInstancesLevel1</dd></dl></div>
    </li><li name="monix.eval.TaskInstancesLevel1#catsParallel" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="catsParallel:monix.eval.instances.CatsParallelForTask"></a><a id="catsParallel:CatsParallelForTask"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#catsParallel:monix.eval.instances.CatsParallelForTask" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">catsParallel</span><span class="result">: <a href="instances/CatsParallelForTask.html" class="extype" name="monix.eval.instances.CatsParallelForTask">CatsParallelForTask</a></span>
      </span>
      
      <p class="shortcomment cmt">Global instance for <code>cats.Parallel</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Global instance for <code>cats.Parallel</code>.</p><p>The <code>Parallel</code> type class is useful for processing
things in parallel in a generic way, usable with
Cats' utils and syntax:</p><pre><span class="kw">import</span> cats.syntax.all._

(taskA, taskB, taskC).parMap { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}</pre><p>Seek more info about Cats, the standard library for FP, at:</p><ul><li><a href="https://typelevel.org/cats/" target="_blank">typelevel/cats</a></li><li><a href="https://github.com/typelevel/cats-effect" target="_blank">typelevel/cats-effect</a>
</li></ul></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskInstancesLevel1</dd></dl></div>
    </li><li name="monix.eval.TaskInstancesLevel0#catsSemigroup" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="catsSemigroup[A](implicitA:cats.Semigroup[A]):cats.Semigroup[monix.eval.Task[A]]"></a><a id="catsSemigroup[A](Semigroup[A]):Semigroup[Task[A]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#catsSemigroup[A](implicitA:cats.Semigroup[A]):cats.Semigroup[monix.eval.Task[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">catsSemigroup</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span class="extype" name="cats.Semigroup">Semigroup</span>[<span class="extype" name="monix.eval.TaskInstancesLevel0.catsSemigroup.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="cats.Semigroup">Semigroup</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.TaskInstancesLevel0.catsSemigroup.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given an <code>A</code> type that has a <code>cats.Semigroup[A]</code> implementation,
then this provides the evidence that <code>Task[A]</code> also has
a <code>Semigroup[Task[A]]</code> implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Given an <code>A</code> type that has a <code>cats.Semigroup[A]</code> implementation,
then this provides the evidence that <code>Task[A]</code> also has
a <code>Semigroup[Task[A]]</code> implementation.</p><p>This has a lower-level priority than <a href="#catsMonoid[A](implicitA:cats.Monoid[A]):cats.Monoid[monix.eval.Task[A]]" class="extmbr" name="monix.eval.Task#catsMonoid">Task.catsMonoid</a>
in order to avoid conflicts.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskInstancesLevel0</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="monix.eval.Task#coeval" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="coeval[A](a:monix.eval.Coeval[A]):monix.eval.Task[A]"></a><a id="coeval[A](Coeval[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#coeval[A](a:monix.eval.Coeval[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">coeval</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <a href="Coeval.html" class="extype" name="monix.eval.Coeval">Coeval</a>[<span class="extype" name="monix.eval.Task.coeval.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.coeval.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Transforms a <a href="Coeval.html" class="extype" name="monix.eval.Coeval">Coeval</a> into a <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>.</p>
    </li><li name="monix.eval.Task#create" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="create[A](register:(monix.execution.Scheduler,monix.eval.Callback[A])=&gt;monix.execution.Cancelable):monix.eval.Task[A]"></a><a id="create[A]((Scheduler,Callback[A])⇒Cancelable):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#create[A](register:(monix.execution.Scheduler,monix.eval.Callback[A])=&gt;monix.execution.Cancelable):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">create</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="register">register: (<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>, <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>[<span class="extype" name="monix.eval.Task.create.A">A</span>]) ⇒ <a href="../execution/Cancelable.html" class="extype" name="monix.execution.Cancelable">Cancelable</a></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.create.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Create a <code>Task</code> from an
        asynchronous computation, which takes the form of a
        function with which we can register a callback.</p><div class="fullcomment"><div class="comment cmt"><p>Create a <code>Task</code> from an
        asynchronous computation, which takes the form of a
        function with which we can register a callback.</p><p>        This can be used to translate from a callback-based API to
        a straightforward monadic version.</p></div><dl class="paramcmts block"><dt class="param">register</dt><dd class="cmt"><p>is a function that will be called when
        this <code>Task</code> is executed, receiving a callback as a
        parameter, a callback that the user is supposed to call in
        order to signal the desired outcome of this <code>Task</code>.</p></dd></dl></div>
    </li><li name="monix.eval.Task#defaultOptions" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="defaultOptions:monix.eval.Task.Options"></a><a id="defaultOptions:Options"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#defaultOptions:monix.eval.Task.Options" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">defaultOptions</span><span class="result">: <a href="Task$$Options.html" class="extype" name="monix.eval.Task.Options">Options</a></span>
      </span>
      
      <p class="shortcomment cmt">Default <a href="Task$$Options.html" class="extype" name="monix.eval.Task.Options">Options</a> to use for <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> evaluation,
thus:</p><div class="fullcomment"><div class="comment cmt"><p>Default <a href="Task$$Options.html" class="extype" name="monix.eval.Task.Options">Options</a> to use for <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> evaluation,
thus:</p><ul><li><code>autoCancelableRunLoops</code> is <code>false</code> by default</li><li><code>localContextPropagation</code> is <code>false</code> by default</li></ul><p>On top of the JVM the default can be overridden by
setting the following system properties:</p><ul><li><code>monix.environment.autoCancelableRunLoops</code>
   (<code>true</code>, <code>yes</code> or <code>1</code> for enabling)</li><li><code>monix.environment.localContextPropagation</code>
   (<code>true</code>, <code>yes</code> or <code>1</code> for enabling)
</li></ul></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="Task$$Options.html" class="extype" name="monix.eval.Task.Options">Task.Options</a></p></span></dd></dl></div>
    </li><li name="monix.eval.Task#defer" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="defer[A](fa:=&gt;monix.eval.Task[A]):monix.eval.Task[A]"></a><a id="defer[A](⇒Task[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#defer[A](fa:=&gt;monix.eval.Task[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">defer</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="fa">fa: ⇒ <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.defer.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.defer.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Promote a non-strict value representing a Task to a Task of the
same type.</p>
    </li><li name="monix.eval.Task#deferAction" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="deferAction[A](f:monix.execution.Scheduler=&gt;monix.eval.Task[A]):monix.eval.Task[A]"></a><a id="deferAction[A]((Scheduler)⇒Task[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#deferAction[A](f:monix.execution.Scheduler=&gt;monix.eval.Task[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">deferAction</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: (<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>) ⇒ <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.deferAction.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.deferAction.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Defers the creation of a <code>Task</code> by using the provided
function, which has the ability to inject a needed
<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Defers the creation of a <code>Task</code> by using the provided
function, which has the ability to inject a needed
<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>.</p><p>Example:</p><pre><span class="kw">def</span> measureLatency[A](source: Task[A]): Task[(A, <span class="std">Long</span>)] =
  Task.deferAction { <span class="kw">implicit</span> s <span class="kw">=&gt;</span>
    <span class="cmt">// We have our Scheduler, which can inject time, we</span>
    <span class="cmt">// can use it for side-effectful operations</span>
    <span class="kw">val</span> start = s.currentTimeMillis()

    source.map { a <span class="kw">=&gt;</span>
      <span class="kw">val</span> finish = s.currentTimeMillis()
      (a, finish - start)
    }
  }</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function that's going to be called when the
       resulting <code>Task</code> gets evaluated</p></dd></dl></div>
    </li><li name="monix.eval.Task#deferFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="deferFuture[A](fa:=&gt;scala.concurrent.Future[A]):monix.eval.Task[A]"></a><a id="deferFuture[A](⇒Future[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#deferFuture[A](fa:=&gt;scala.concurrent.Future[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">deferFuture</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="fa">fa: ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/concurrent/Future.html#scala.concurrent.Future" class="extype" name="scala.concurrent.Future">Future</a>[<span class="extype" name="monix.eval.Task.deferFuture.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.deferFuture.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Promote a non-strict Scala <code>Future</code> to a <code>Task</code> of the same type.</p><div class="fullcomment"><div class="comment cmt"><p>Promote a non-strict Scala <code>Future</code> to a <code>Task</code> of the same type.</p><p>The equivalent of doing:</p><pre>Task.defer(Task.fromFuture(fa))</pre></div></div>
    </li><li name="monix.eval.Task#deferFutureAction" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="deferFutureAction[A](f:monix.execution.Scheduler=&gt;scala.concurrent.Future[A]):monix.eval.Task[A]"></a><a id="deferFutureAction[A]((Scheduler)⇒Future[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#deferFutureAction[A](f:monix.execution.Scheduler=&gt;scala.concurrent.Future[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">deferFutureAction</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: (<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/concurrent/Future.html#scala.concurrent.Future" class="extype" name="scala.concurrent.Future">Future</a>[<span class="extype" name="monix.eval.Task.deferFutureAction.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.deferFutureAction.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Wraps calls that generate <code>Future</code> results into <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>, provided
a callback with an injected <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>
to act as the necessary <code>ExecutionContext</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps calls that generate <code>Future</code> results into <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>, provided
a callback with an injected <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>
to act as the necessary <code>ExecutionContext</code>.</p><p>This builder helps with wrapping <code>Future</code>-enabled APIs that need
an implicit <code>ExecutionContext</code> to work. Consider this example:</p><pre><span class="kw">import</span> scala.concurrent.{ExecutionContext, Future}

<span class="kw">def</span> sumFuture(list: <span class="std">Seq</span>[<span class="std">Int</span>])(<span class="kw">implicit</span> ec: ExecutionContext): Future[<span class="std">Int</span>] =
  Future(list.sum)</pre><p>We'd like to wrap this function into one that returns a lazy
<code>Task</code> that evaluates this sum every time it is called, because
that's how tasks work best. However in order to invoke this
function an <code>ExecutionContext</code> is needed:</p><pre><span class="kw">def</span> sumTask(list: <span class="std">Seq</span>[<span class="std">Int</span>])(<span class="kw">implicit</span> ec: ExecutionContext): Task[<span class="std">Int</span>] =
  Task.deferFuture(sumFuture(list))</pre><p>But this is not only superfluous, but against the best practices
of using <code>Task</code>. The difference is that <code>Task</code> takes a
<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a> (inheriting from
<code>ExecutionContext</code>) only when <a href="Task.html#runAsync(cb:monix.eval.Callback[A])(implicits:monix.execution.Scheduler):monix.execution.Cancelable" class="extmbr" name="monix.eval.Task#runAsync">runAsync</a>
happens. But with <code>deferFutureAction</code> we get to have an injected
<code>Scheduler</code> in the passed callback:</p><pre><span class="kw">def</span> sumTask(list: <span class="std">Seq</span>[<span class="std">Int</span>]): Task[<span class="std">Int</span>] =
  Task.deferFutureAction { <span class="kw">implicit</span> scheduler <span class="kw">=&gt;</span>
    sumFuture(list)
  }</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function that's going to be executed when the task
       gets evaluated, generating the wrapped <code>Future</code></p></dd></dl></div>
    </li><li name="monix.eval.Task#delay" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="delay[A](a:=&gt;A):monix.eval.Task[A]"></a><a id="delay[A](⇒A):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#delay[A](a:=&gt;A):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delay</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: ⇒ <span class="extype" name="monix.eval.Task.delay.A">A</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.delay.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Alias for <a href="#eval[A](a:=&gt;A):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#eval">eval</a>.</p>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="monix.eval.Task#eval" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eval[A](a:=&gt;A):monix.eval.Task[A]"></a><a id="eval[A](⇒A):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#eval[A](a:=&gt;A):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eval</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: ⇒ <span class="extype" name="monix.eval.Task.eval.A">A</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.eval.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Promote a non-strict value to a Task, catching exceptions in the
process.</p><div class="fullcomment"><div class="comment cmt"><p>Promote a non-strict value to a Task, catching exceptions in the
process.</p><p>Note that since <code>Task</code> is not memoized, this will recompute the
value each time the <code>Task</code> is executed.
</p></div></div>
    </li><li name="monix.eval.Task#evalOnce" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="evalOnce[A](a:=&gt;A):monix.eval.Task[A]"></a><a id="evalOnce[A](⇒A):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#evalOnce[A](a:=&gt;A):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalOnce</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: ⇒ <span class="extype" name="monix.eval.Task.evalOnce.A">A</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.evalOnce.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Promote a non-strict value to a Task that is memoized on the first
evaluation, the result being then available on subsequent evaluations.</p>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="monix.eval.Task#fromEffect" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fromEffect[F[_],A](fa:F[A])(implicitF:cats.effect.Effect[F]):monix.eval.Task[A]"></a><a id="fromEffect[F[_],A](F[A])(Effect[F]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#fromEffect[F[_],A](fa:F[A])(implicitF:cats.effect.Effect[F]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromEffect</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="params">(<span name="fa">fa: <span class="extype" name="monix.eval.Task.fromEffect.F">F</span>[<span class="extype" name="monix.eval.Task.fromEffect.A">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span class="extype" name="cats.effect.Effect">Effect</span>[<span class="extype" name="monix.eval.Task.fromEffect.F">F</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fromEffect.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instance out of any data type that implements
either <code>cats.effect.ConcurrentEffect</code> or <code>cats.effect.Effect</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instance out of any data type that implements
either <code>cats.effect.ConcurrentEffect</code> or <code>cats.effect.Effect</code>.</p><p>This method discriminates between <code>Effect</code> and <code>ConcurrentEffect</code>
using their subtype encoding (<code>ConcurrentEffect &lt;: Effect</code>),
such that:</p><ul><li>if the indicated type has a <code>ConcurrentEffect</code> implementation
   and if the indicated value is cancelable, then the resulting
   task is also cancelable</li><li>otherwise, if the indicated type only implements <code>Effect</code>,
   then the conversion is still possible, but the resulting task
   isn't cancelable</li></ul><p>Example:</p><pre><span class="kw">import</span> cats.effect._
<span class="kw">import</span> cats.syntax.all._

<span class="kw">val</span> io = Timer[IO].sleep(<span class="num">5.</span>seconds) *&gt; IO(println(<span class="lit">"Hello!"</span>))

<span class="cmt">// Resulting task is cancelable</span>
<span class="kw">val</span> task: Task[<span class="std">Unit</span>] = Task.fromEffect(io)</pre></div><dl class="paramcmts block"><dt class="param">F</dt><dd class="cmt"><p>is the <code>cats.effect.Effect</code> type class instance necessary
       for converting to <code>Task</code>; this instance can also be a
       <code>cats.effect.Concurrent</code>, in which case the resulting
       <code>Task</code> value is cancelable if the source is</p></dd></dl></div>
    </li><li name="monix.eval.Task#fromEval" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="fromEval[A](a:cats.Eval[A]):monix.eval.Task[A]"></a><a id="fromEval[A](cats.Eval[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#fromEval[A](a:cats.Eval[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromEval</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <a href="http://typelevel.org/cats/api/cats/Eval.html#cats.Eval" class="extype" name="cats.Eval">cats.Eval</a>[<span class="extype" name="monix.eval.Task.fromEval.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fromEval.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instance out of a <code>cats.Eval</code>.</p>
    </li><li name="monix.eval.Task#fromFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fromFuture[A](f:scala.concurrent.Future[A]):monix.eval.Task[A]"></a><a id="fromFuture[A](Future[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#fromFuture[A](f:scala.concurrent.Future[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromFuture</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: <a href="http://www.scala-lang.org/api/2.12.4/scala/concurrent/Future.html#scala.concurrent.Future" class="extype" name="scala.concurrent.Future">Future</a>[<span class="extype" name="monix.eval.Task.fromFuture.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fromFuture.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Converts the given Scala <code>Future</code> into a <code>Task</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the given Scala <code>Future</code> into a <code>Task</code>.</p><p>NOTE: if you want to defer the creation of the future, use
in combination with <a href="#defer[A](fa:=&gt;monix.eval.Task[A]):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#defer">defer</a>.
</p></div></div>
    </li><li name="monix.eval.Task#fromIO" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fromIO[A](ioa:cats.effect.IO[A]):monix.eval.Task[A]"></a><a id="fromIO[A](IO[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#fromIO[A](ioa:cats.effect.IO[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromIO</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="ioa">ioa: <span class="extype" name="cats.effect.IO">IO</span>[<span class="extype" name="monix.eval.Task.fromIO.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fromIO.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Converts <code>IO[A]</code> values into <code>Task[A]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts <code>IO[A]</code> values into <code>Task[A]</code>.</p><p>Preserves cancelability, if the source <code>IO</code> value is cancelable.</p><pre><span class="kw">import</span> cats.effect._
<span class="kw">import</span> cats.syntax.all._
<span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> io: IO[<span class="std">Unit</span>] =
  IO.sleep(<span class="num">5.</span>seconds) *&gt; IO(println(<span class="lit">"Hello!"</span>))

<span class="cmt">// Conversion; note the resulting task is also</span>
<span class="cmt">// cancelable if the source is</span>
<span class="kw">val</span> task: Task[<span class="std">Unit</span>] = Task.fromIO(ioa)</pre><p>Also see <a href="#fromEffect[F[_],A](fa:F[A])(implicitF:cats.effect.Effect[F]):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#fromEffect">fromEffect</a>, the more generic conversion utility.
</p></div></div>
    </li><li name="monix.eval.Task#fromTry" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="fromTry[A](a:scala.util.Try[A]):monix.eval.Task[A]"></a><a id="fromTry[A](Try[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#fromTry[A](a:scala.util.Try[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromTry</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <a href="http://www.scala-lang.org/api/2.12.4/scala/util/Try.html#scala.util.Try" class="extype" name="scala.util.Try">Try</a>[<span class="extype" name="monix.eval.Task.fromTry.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fromTry.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instance out of a Scala <code>Try</code>.</p>
    </li><li name="monix.eval.Task#gather" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]"></a><a id="gather[A,M[X]&lt;:TraversableOnce[X]](M[Task[A]])(CanBuildFrom[M[Task[A]],A,M[A]]):Task[M[A]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gather</span><span class="tparams">[<span name="A">A</span>, <span name="M">M<span class="tparams">[<span name="X">X</span>]</span> &lt;: <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<span class="extype" name="monix.eval.Task.gather.M.X">X</span>]</span>]</span><span class="params">(<span name="in">in: <span class="extype" name="monix.eval.Task.gather.M">M</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.gather.A">A</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cbf">cbf: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/generic/CanBuildFrom.html#scala.collection.generic.CanBuildFrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<span class="extype" name="monix.eval.Task.gather.M">M</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.gather.A">A</span>]], <span class="extype" name="monix.eval.Task.gather.A">A</span>, <span class="extype" name="monix.eval.Task.gather.M">M</span>[<span class="extype" name="monix.eval.Task.gather.A">A</span>]]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.gather.M">M</span>[<span class="extype" name="monix.eval.Task.gather.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Nondeterministically gather results from the given collection of tasks,
returning a task that will signal the same type of collection of results
once all tasks are finished.</p><div class="fullcomment"><div class="comment cmt"><p>Nondeterministically gather results from the given collection of tasks,
returning a task that will signal the same type of collection of results
once all tasks are finished.</p><p>This function is the nondeterministic analogue of <code>sequence</code> and should
behave identically to <code>sequence</code> so long as there is no interaction between
the effects being gathered. However, unlike <code>sequence</code>, which decides on
a total order of effects, the effects in a <code>gather</code> are unordered with
respect to each other.</p><p>Although the effects are unordered, we ensure the order of results
matches the order of the input sequence. Also see <a href="#gatherUnordered[A](in:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[List[A]]" class="extmbr" name="monix.eval.Task#gatherUnordered">gatherUnordered</a>
for the more efficient alternative.
</p></div></div>
    </li><li name="monix.eval.Task#gatherUnordered" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="gatherUnordered[A](in:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[List[A]]"></a><a id="gatherUnordered[A](TraversableOnce[Task[A]]):Task[List[A]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#gatherUnordered[A](in:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[List[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gatherUnordered</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="in">in: <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.gatherUnordered.A">A</span>]]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="monix.eval.Task.gatherUnordered.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Nondeterministically gather results from the given collection of tasks,
without keeping the original ordering of results.</p><div class="fullcomment"><div class="comment cmt"><p>Nondeterministically gather results from the given collection of tasks,
without keeping the original ordering of results.</p><p>If the tasks in the list are set to execute asynchronously, forking
logical threads, then the tasks will execute in parallel.</p><p>This function is similar to <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">gather</a>, but neither the effects nor the
results will be ordered. Useful when you don't need ordering because:</p><ul><li>it has non-blocking behavior (but not wait-free)</li><li>it can be more efficient (compared with <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">gather</a>), but not
   necessarily (if you care about performance, then test)
</li></ul></div><dl class="paramcmts block"><dt class="param">in</dt><dd class="cmt"><p>is a list of tasks to execute</p></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="monix.eval.Task#map2" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]"></a><a id="map2[A1,A2,R](Task[A1],Task[A2])((A1,A2)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#map2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map2</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map2.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map2.A2">A2</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.map2.A1">A1</span>, <span class="extype" name="monix.eval.Task.map2.A2">A2</span>) ⇒ <span class="extype" name="monix.eval.Task.map2.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map2.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 2 <code>Task</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 2 <code>Task</code> values, applying the given mapping function.</p><p>Returns a new <code>Task</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#sequence">Task.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="Task.html#flatMap[B](f:A=&gt;monix.eval.Task[B]):monix.eval.Task[B]" class="extmbr" name="monix.eval.Task#flatMap">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)

<span class="cmt">// Yields Success(3)</span>
Task.map2(fa1, fa2) { (a, b) <span class="kw">=&gt;</span>
  a + b
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.map2(fa1, Task.raiseError(e)) { (a, b) <span class="kw">=&gt;</span>
  a + b
}</pre><p>See <a href="#parMap2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap2">Task.parMap2</a> for parallel processing.
</p></div></div>
    </li><li name="monix.eval.Task#map3" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map3[A1,A2,A3,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3])(f:(A1,A2,A3)=&gt;R):monix.eval.Task[R]"></a><a id="map3[A1,A2,A3,R](Task[A1],Task[A2],Task[A3])((A1,A2,A3)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#map3[A1,A2,A3,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3])(f:(A1,A2,A3)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map3</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map3.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map3.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map3.A3">A3</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.map3.A1">A1</span>, <span class="extype" name="monix.eval.Task.map3.A2">A2</span>, <span class="extype" name="monix.eval.Task.map3.A3">A3</span>) ⇒ <span class="extype" name="monix.eval.Task.map3.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map3.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 3 <code>Task</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 3 <code>Task</code> values, applying the given mapping function.</p><p>Returns a new <code>Task</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#sequence">Task.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="Task.html#flatMap[B](f:A=&gt;monix.eval.Task[B]):monix.eval.Task[B]" class="extmbr" name="monix.eval.Task#flatMap">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)
<span class="kw">val</span> fa3 = Task(<span class="num">3</span>)

<span class="cmt">// Yields Success(6)</span>
Task.map3(fa1, fa2, fa3) { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.map3(fa1, Task.raiseError(e), fa3) { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}</pre><p>See <a href="#parMap3[A1,A2,A3,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3])(f:(A1,A2,A3)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap3">Task.parMap3</a> for parallel processing.
</p></div></div>
    </li><li name="monix.eval.Task#map4" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map4[A1,A2,A3,A4,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4])(f:(A1,A2,A3,A4)=&gt;R):monix.eval.Task[R]"></a><a id="map4[A1,A2,A3,A4,R](Task[A1],Task[A2],Task[A3],Task[A4])((A1,A2,A3,A4)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#map4[A1,A2,A3,A4,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4])(f:(A1,A2,A3,A4)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map4</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map4.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map4.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map4.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map4.A4">A4</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.map4.A1">A1</span>, <span class="extype" name="monix.eval.Task.map4.A2">A2</span>, <span class="extype" name="monix.eval.Task.map4.A3">A3</span>, <span class="extype" name="monix.eval.Task.map4.A4">A4</span>) ⇒ <span class="extype" name="monix.eval.Task.map4.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map4.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 4 <code>Task</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 4 <code>Task</code> values, applying the given mapping function.</p><p>Returns a new <code>Task</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#sequence">Task.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="Task.html#flatMap[B](f:A=&gt;monix.eval.Task[B]):monix.eval.Task[B]" class="extmbr" name="monix.eval.Task#flatMap">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)
<span class="kw">val</span> fa3 = Task(<span class="num">3</span>)
<span class="kw">val</span> fa4 = Task(<span class="num">4</span>)

<span class="cmt">// Yields Success(10)</span>
Task.map4(fa1, fa2, fa3, fa4) { (a, b, c, d) <span class="kw">=&gt;</span>
  a + b + c + d
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.map4(fa1, Task.raiseError(e), fa3, fa4) {
  (a, b, c, d) <span class="kw">=&gt;</span> a + b + c + d
}</pre><p>See <a href="#parMap4[A1,A2,A3,A4,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4])(f:(A1,A2,A3,A4)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap4">Task.parMap4</a> for parallel processing.
</p></div></div>
    </li><li name="monix.eval.Task#map5" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map5[A1,A2,A3,A4,A5,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.eval.Task[R]"></a><a id="map5[A1,A2,A3,A4,A5,R](Task[A1],Task[A2],Task[A3],Task[A4],Task[A5])((A1,A2,A3,A4,A5)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#map5[A1,A2,A3,A4,A5,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map5</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map5.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map5.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map5.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map5.A4">A4</span>]</span>, <span name="fa5">fa5: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map5.A5">A5</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.map5.A1">A1</span>, <span class="extype" name="monix.eval.Task.map5.A2">A2</span>, <span class="extype" name="monix.eval.Task.map5.A3">A3</span>, <span class="extype" name="monix.eval.Task.map5.A4">A4</span>, <span class="extype" name="monix.eval.Task.map5.A5">A5</span>) ⇒ <span class="extype" name="monix.eval.Task.map5.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map5.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 5 <code>Task</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 5 <code>Task</code> values, applying the given mapping function.</p><p>Returns a new <code>Task</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#sequence">Task.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="Task.html#flatMap[B](f:A=&gt;monix.eval.Task[B]):monix.eval.Task[B]" class="extmbr" name="monix.eval.Task#flatMap">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)
<span class="kw">val</span> fa3 = Task(<span class="num">3</span>)
<span class="kw">val</span> fa4 = Task(<span class="num">4</span>)
<span class="kw">val</span> fa5 = Task(<span class="num">5</span>)

<span class="cmt">// Yields Success(15)</span>
Task.map5(fa1, fa2, fa3, fa4, fa5) { (a, b, c, d, e) <span class="kw">=&gt;</span>
  a + b + c + d + e
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.map5(fa1, Task.raiseError(e), fa3, fa4, fa5) {
  (a, b, c, d, e) <span class="kw">=&gt;</span> a + b + c + d + e
}</pre><p>See <a href="#parMap5[A1,A2,A3,A4,A5,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap5">Task.parMap5</a> for parallel processing.
</p></div></div>
    </li><li name="monix.eval.Task#map6" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map6[A1,A2,A3,A4,A5,A6,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.eval.Task[R]"></a><a id="map6[A1,A2,A3,A4,A5,A6,R](Task[A1],Task[A2],Task[A3],Task[A4],Task[A5],Task[A6])((A1,A2,A3,A4,A5,A6)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#map6[A1,A2,A3,A4,A5,A6,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map6</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="A6">A6</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map6.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map6.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map6.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map6.A4">A4</span>]</span>, <span name="fa5">fa5: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map6.A5">A5</span>]</span>, <span name="fa6">fa6: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map6.A6">A6</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.map6.A1">A1</span>, <span class="extype" name="monix.eval.Task.map6.A2">A2</span>, <span class="extype" name="monix.eval.Task.map6.A3">A3</span>, <span class="extype" name="monix.eval.Task.map6.A4">A4</span>, <span class="extype" name="monix.eval.Task.map6.A5">A5</span>, <span class="extype" name="monix.eval.Task.map6.A6">A6</span>) ⇒ <span class="extype" name="monix.eval.Task.map6.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.map6.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 6 <code>Task</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 6 <code>Task</code> values, applying the given mapping function.</p><p>Returns a new <code>Task</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#sequence">Task.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="Task.html#flatMap[B](f:A=&gt;monix.eval.Task[B]):monix.eval.Task[B]" class="extmbr" name="monix.eval.Task#flatMap">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)
<span class="kw">val</span> fa3 = Task(<span class="num">3</span>)
<span class="kw">val</span> fa4 = Task(<span class="num">4</span>)
<span class="kw">val</span> fa5 = Task(<span class="num">5</span>)
<span class="kw">val</span> fa6 = Task(<span class="num">6</span>)

<span class="cmt">// Yields Success(21)</span>
Task.map6(fa1, fa2, fa3, fa4, fa5, fa6) { (a, b, c, d, e, f) <span class="kw">=&gt;</span>
  a + b + c + d + e + f
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.map6(fa1, Task.raiseError(e), fa3, fa4, fa5, fa6) {
  (a, b, c, d, e, f) <span class="kw">=&gt;</span> a + b + c + d + e + f
}</pre><p>See <a href="#parMap6[A1,A2,A3,A4,A5,A6,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap6">Task.parMap6</a> for parallel processing.
</p></div></div>
    </li><li name="monix.eval.Task#mapBoth" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mapBoth[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]"></a><a id="mapBoth[A1,A2,R](Task[A1],Task[A2])((A1,A2)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#mapBoth[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapBoth</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.mapBoth.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.mapBoth.A2">A2</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.mapBoth.A1">A1</span>, <span class="extype" name="monix.eval.Task.mapBoth.A2">A2</span>) ⇒ <span class="extype" name="monix.eval.Task.mapBoth.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.mapBoth.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Apply a mapping functions to the results of two tasks, nondeterministically
ordering their effects.</p><div class="fullcomment"><div class="comment cmt"><p>Apply a mapping functions to the results of two tasks, nondeterministically
ordering their effects.</p><p>If the two tasks are synchronous, they'll get executed one
after the other, with the result being available asynchronously.
If the two tasks are asynchronous, they'll get scheduled for execution
at the same time and in a multi-threading environment they'll execute
in parallel and have their results synchronized.
</p></div></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Boolean.html#scala.Boolean" class="extype" name="scala.Boolean">Boolean</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="monix.eval.Task#never" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="never[A]:monix.eval.Task[A]"></a><a id="never[A]:Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#never[A]:monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">never</span><span class="tparams">[<span name="A">A</span>]</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.never.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instance that upon evaluation will never complete.</p>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="monix.eval.Task#now" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="now[A](a:A):monix.eval.Task[A]"></a><a id="now[A](A):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#now[A](a:A):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">now</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <span class="extype" name="monix.eval.Task.now.A">A</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.now.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a <code>Task</code> that on execution is always successful, emitting
the given strict value.</p>
    </li><li name="monix.eval.Task#parMap2" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parMap2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]"></a><a id="parMap2[A1,A2,R](Task[A1],Task[A2])((A1,A2)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#parMap2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parMap2</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap2.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap2.A2">A2</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.parMap2.A1">A1</span>, <span class="extype" name="monix.eval.Task.parMap2.A2">A2</span>) ⇒ <span class="extype" name="monix.eval.Task.parMap2.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap2.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 2 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 2 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><p>This is a specialized <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">Task.gather</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)

<span class="cmt">// Yields Success(3)</span>
Task.parMap2(fa1, fa2) { (a, b) <span class="kw">=&gt;</span>
  a + b
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.parMap2(fa1, Task.raiseError(e)) { (a, b) <span class="kw">=&gt;</span>
  a + b
}</pre><p>See <a href="#map2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#map2">Task.map2</a> for sequential processing.
</p></div></div>
    </li><li name="monix.eval.Task#parMap3" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parMap3[A1,A2,A3,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3])(f:(A1,A2,A3)=&gt;R):monix.eval.Task[R]"></a><a id="parMap3[A1,A2,A3,R](Task[A1],Task[A2],Task[A3])((A1,A2,A3)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#parMap3[A1,A2,A3,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3])(f:(A1,A2,A3)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parMap3</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap3.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap3.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap3.A3">A3</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.parMap3.A1">A1</span>, <span class="extype" name="monix.eval.Task.parMap3.A2">A2</span>, <span class="extype" name="monix.eval.Task.parMap3.A3">A3</span>) ⇒ <span class="extype" name="monix.eval.Task.parMap3.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap3.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 3 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 3 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><p>This is a specialized <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">Task.gather</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)
<span class="kw">val</span> fa3 = Task(<span class="num">3</span>)

<span class="cmt">// Yields Success(6)</span>
Task.parMap3(fa1, fa2, fa3) { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.parMap3(fa1, Task.raiseError(e), fa3) { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}</pre><p>See <a href="#map3[A1,A2,A3,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3])(f:(A1,A2,A3)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#map3">Task.map3</a> for sequential processing.
</p></div></div>
    </li><li name="monix.eval.Task#parMap4" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parMap4[A1,A2,A3,A4,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4])(f:(A1,A2,A3,A4)=&gt;R):monix.eval.Task[R]"></a><a id="parMap4[A1,A2,A3,A4,R](Task[A1],Task[A2],Task[A3],Task[A4])((A1,A2,A3,A4)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#parMap4[A1,A2,A3,A4,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4])(f:(A1,A2,A3,A4)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parMap4</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap4.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap4.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap4.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap4.A4">A4</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.parMap4.A1">A1</span>, <span class="extype" name="monix.eval.Task.parMap4.A2">A2</span>, <span class="extype" name="monix.eval.Task.parMap4.A3">A3</span>, <span class="extype" name="monix.eval.Task.parMap4.A4">A4</span>) ⇒ <span class="extype" name="monix.eval.Task.parMap4.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap4.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 4 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 4 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><p>This is a specialized <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">Task.gather</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)
<span class="kw">val</span> fa3 = Task(<span class="num">3</span>)
<span class="kw">val</span> fa4 = Task(<span class="num">4</span>)

<span class="cmt">// Yields Success(10)</span>
Task.parMap4(fa1, fa2, fa3, fa4) { (a, b, c, d) <span class="kw">=&gt;</span>
  a + b + c + d
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.parMap4(fa1, Task.raiseError(e), fa3, fa4) {
  (a, b, c, d) <span class="kw">=&gt;</span> a + b + c + d
}</pre><p>See <a href="#map4[A1,A2,A3,A4,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4])(f:(A1,A2,A3,A4)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#map4">Task.map4</a> for sequential processing.
</p></div></div>
    </li><li name="monix.eval.Task#parMap5" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parMap5[A1,A2,A3,A4,A5,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.eval.Task[R]"></a><a id="parMap5[A1,A2,A3,A4,A5,R](Task[A1],Task[A2],Task[A3],Task[A4],Task[A5])((A1,A2,A3,A4,A5)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#parMap5[A1,A2,A3,A4,A5,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parMap5</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap5.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap5.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap5.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap5.A4">A4</span>]</span>, <span name="fa5">fa5: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap5.A5">A5</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.parMap5.A1">A1</span>, <span class="extype" name="monix.eval.Task.parMap5.A2">A2</span>, <span class="extype" name="monix.eval.Task.parMap5.A3">A3</span>, <span class="extype" name="monix.eval.Task.parMap5.A4">A4</span>, <span class="extype" name="monix.eval.Task.parMap5.A5">A5</span>) ⇒ <span class="extype" name="monix.eval.Task.parMap5.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap5.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 5 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 5 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><p>This is a specialized <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">Task.gather</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)
<span class="kw">val</span> fa3 = Task(<span class="num">3</span>)
<span class="kw">val</span> fa4 = Task(<span class="num">4</span>)
<span class="kw">val</span> fa5 = Task(<span class="num">5</span>)

<span class="cmt">// Yields Success(15)</span>
Task.parMap5(fa1, fa2, fa3, fa4, fa5) { (a, b, c, d, e) <span class="kw">=&gt;</span>
  a + b + c + d + e
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.parMap5(fa1, Task.raiseError(e), fa3, fa4, fa5) {
  (a, b, c, d, e) <span class="kw">=&gt;</span> a + b + c + d + e
}</pre><p>See <a href="#map5[A1,A2,A3,A4,A5,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#map5">Task.map5</a> for sequential processing.
</p></div></div>
    </li><li name="monix.eval.Task#parMap6" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parMap6[A1,A2,A3,A4,A5,A6,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.eval.Task[R]"></a><a id="parMap6[A1,A2,A3,A4,A5,A6,R](Task[A1],Task[A2],Task[A3],Task[A4],Task[A5],Task[A6])((A1,A2,A3,A4,A5,A6)⇒R):Task[R]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#parMap6[A1,A2,A3,A4,A5,A6,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.eval.Task[R]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parMap6</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="A6">A6</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap6.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap6.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap6.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap6.A4">A4</span>]</span>, <span name="fa5">fa5: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap6.A5">A5</span>]</span>, <span name="fa6">fa6: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap6.A6">A6</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.parMap6.A1">A1</span>, <span class="extype" name="monix.eval.Task.parMap6.A2">A2</span>, <span class="extype" name="monix.eval.Task.parMap6.A3">A3</span>, <span class="extype" name="monix.eval.Task.parMap6.A4">A4</span>, <span class="extype" name="monix.eval.Task.parMap6.A5">A5</span>, <span class="extype" name="monix.eval.Task.parMap6.A6">A6</span>) ⇒ <span class="extype" name="monix.eval.Task.parMap6.R">R</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.parMap6.R">R</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs 6 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 6 <code>Task</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><p>This is a specialized <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">Task.gather</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = Task(<span class="num">1</span>)
<span class="kw">val</span> fa2 = Task(<span class="num">2</span>)
<span class="kw">val</span> fa3 = Task(<span class="num">3</span>)
<span class="kw">val</span> fa4 = Task(<span class="num">4</span>)
<span class="kw">val</span> fa5 = Task(<span class="num">5</span>)
<span class="kw">val</span> fa6 = Task(<span class="num">6</span>)

<span class="cmt">// Yields Success(21)</span>
Task.parMap6(fa1, fa2, fa3, fa4, fa5, fa6) { (a, b, c, d, e, f) <span class="kw">=&gt;</span>
  a + b + c + d + e + f
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
Task.parMap6(fa1, Task.raiseError(e), fa3, fa4, fa5, fa6) {
  (a, b, c, d, e, f) <span class="kw">=&gt;</span> a + b + c + d + e + f
}</pre><p>See <a href="#map6[A1,A2,A3,A4,A5,A6,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#map6">Task.map6</a> for sequential processing.
</p></div></div>
    </li><li name="monix.eval.Task#pure" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pure[A](a:A):monix.eval.Task[A]"></a><a id="pure[A](A):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#pure[A](a:A):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pure</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <span class="extype" name="monix.eval.Task.pure.A">A</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.pure.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Lifts a value into the task context.</p><div class="fullcomment"><div class="comment cmt"><p>Lifts a value into the task context. Alias for <a href="#now[A](a:A):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#now">now</a>.</p></div></div>
    </li><li name="monix.eval.Task#race" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="race[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[A,B]]"></a><a id="race[A,B](Task[A],Task[B]):Task[Either[A,B]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#race[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[A,B]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">race</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="fa">fa: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.race.A">A</span>]</span>, <span name="fb">fb: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.race.B">B</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="scala.Either">Either</span>[<span class="extype" name="monix.eval.Task.race.A">A</span>, <span class="extype" name="monix.eval.Task.race.B">B</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Run two <code>Task</code> actions concurrently, and return the first to
finish, either in success or error.</p><div class="fullcomment"><div class="comment cmt"><p>Run two <code>Task</code> actions concurrently, and return the first to
finish, either in success or error. The loser of the race is
cancelled.</p><p>The two tasks are executed in parallel, the winner being the
first that signals a result.</p><p>As an example, this would be equivalent with <a href="Task.html#timeout(after:scala.concurrent.duration.FiniteDuration):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#timeout">Task.timeout</a>:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> timeoutError = Task
  .raiseError(<span class="kw">new</span> TimeoutException)
  .delayExecution(<span class="num">5.</span>seconds)

Task.race(myTask, timeoutError)</pre><p>Similarly <a href="Task.html#timeoutTo[B&gt;:A](after:scala.concurrent.duration.FiniteDuration,backup:monix.eval.Task[B]):monix.eval.Task[B]" class="extmbr" name="monix.eval.Task#timeoutTo">Task.timeoutTo</a> is expressed in terms of <code>race</code>.</p><p>Also see <a href="#racePair[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[(A,monix.eval.Fiber[B]),(monix.eval.Fiber[A],B)]]" class="extmbr" name="monix.eval.Task#racePair">racePair</a> for a version that does not cancel
the loser automatically on successful results. And <a href="#raceMany[A](tasks:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#raceMany">raceMany</a>
for a version that races a whole list of tasks.
</p></div></div>
    </li><li name="monix.eval.Task#raceMany" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="raceMany[A](tasks:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[A]"></a><a id="raceMany[A](TraversableOnce[Task[A]]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#raceMany[A](tasks:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">raceMany</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="tasks">tasks: <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.raceMany.A">A</span>]]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.raceMany.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Runs multiple <code>Task</code> actions concurrently, returning the
first to finish, either in success or error.</p><div class="fullcomment"><div class="comment cmt"><p>Runs multiple <code>Task</code> actions concurrently, returning the
first to finish, either in success or error. All losers of the
race get cancelled.</p><p>The tasks get executed in parallel, the winner being the first
that signals a result.</p><pre><span class="kw">val</span> list: <span class="std">List</span>[Task[<span class="std">Int</span>]] = <span class="std">List</span>(t1, t2, t3, ???)

<span class="kw">val</span> winner: Task[<span class="std">Int</span>] = Task.raceMany(list)</pre><p>See <a href="#race[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[A,B]]" class="extmbr" name="monix.eval.Task#race">race</a> or <a href="#racePair[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[(A,monix.eval.Fiber[B]),(monix.eval.Fiber[A],B)]]" class="extmbr" name="monix.eval.Task#racePair">racePair</a> for racing two tasks, for more
control.
</p></div></div>
    </li><li name="monix.eval.Task#racePair" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="racePair[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[(A,monix.eval.Fiber[B]),(monix.eval.Fiber[A],B)]]"></a><a id="racePair[A,B](Task[A],Task[B]):Task[Either[(A,Fiber[B]),(Fiber[A],B)]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#racePair[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[(A,monix.eval.Fiber[B]),(monix.eval.Fiber[A],B)]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">racePair</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="fa">fa: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.racePair.A">A</span>]</span>, <span name="fb">fb: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.racePair.B">B</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="scala.Either">Either</span>[(<span class="extype" name="monix.eval.Task.racePair.A">A</span>, <a href="Fiber.html" class="extype" name="monix.eval.Fiber">Fiber</a>[<span class="extype" name="monix.eval.Task.racePair.B">B</span>]), (<a href="Fiber.html" class="extype" name="monix.eval.Fiber">Fiber</a>[<span class="extype" name="monix.eval.Task.racePair.A">A</span>], <span class="extype" name="monix.eval.Task.racePair.B">B</span>)]]</span>
      </span>
      
      <p class="shortcomment cmt">Run two <code>Task</code> actions concurrently, and returns a pair
containing both the winner's successful value and the loser
represented as a still-unfinished task.</p><div class="fullcomment"><div class="comment cmt"><p>Run two <code>Task</code> actions concurrently, and returns a pair
containing both the winner's successful value and the loser
represented as a still-unfinished task.</p><p>If the first task completes in error, then the result will
complete in error, the other task being cancelled.</p><p>On usage the user has the option of cancelling the losing task,
this being equivalent with plain <a href="#race[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[A,B]]" class="extmbr" name="monix.eval.Task#race">race</a>:</p><pre><span class="kw">val</span> ta: Task[A] = ???
<span class="kw">val</span> tb: Task[B] = ???

Task.racePair(ta, tb).flatMap {
  <span class="kw">case</span> Left((a, taskB)) <span class="kw">=&gt;</span>
    taskB.cancel.map(_ <span class="kw">=&gt;</span> a)
  <span class="kw">case</span> Right((taskA, b)) <span class="kw">=&gt;</span>
    taskA.cancel.map(_ <span class="kw">=&gt;</span> b)
}</pre><p>See <a href="#race[A,B](fa:monix.eval.Task[A],fb:monix.eval.Task[B]):monix.eval.Task[Either[A,B]]" class="extmbr" name="monix.eval.Task#race">race</a> for a simpler version that cancels the loser
immediately or <a href="#raceMany[A](tasks:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#raceMany">raceMany</a> that races collections of tasks.
</p></div></div>
    </li><li name="monix.eval.Task#raiseError" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="raiseError[A](ex:Throwable):monix.eval.Task[A]"></a><a id="raiseError[A](Throwable):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#raiseError[A](ex:Throwable):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">raiseError</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="ex">ex: <span class="extype" name="scala.Throwable">Throwable</span></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.raiseError.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a task that on execution is always finishing in error
emitting the specified exception.</p>
    </li><li name="monix.eval.Task#sequence" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sequence[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]"></a><a id="sequence[A,M[X]&lt;:TraversableOnce[X]](M[Task[A]])(CanBuildFrom[M[Task[A]],A,M[A]]):Task[M[A]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#sequence[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sequence</span><span class="tparams">[<span name="A">A</span>, <span name="M">M<span class="tparams">[<span name="X">X</span>]</span> &lt;: <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<span class="extype" name="monix.eval.Task.sequence.M.X">X</span>]</span>]</span><span class="params">(<span name="in">in: <span class="extype" name="monix.eval.Task.sequence.M">M</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.sequence.A">A</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cbf">cbf: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/generic/CanBuildFrom.html#scala.collection.generic.CanBuildFrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<span class="extype" name="monix.eval.Task.sequence.M">M</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.sequence.A">A</span>]], <span class="extype" name="monix.eval.Task.sequence.A">A</span>, <span class="extype" name="monix.eval.Task.sequence.M">M</span>[<span class="extype" name="monix.eval.Task.sequence.A">A</span>]]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.sequence.M">M</span>[<span class="extype" name="monix.eval.Task.sequence.A">A</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given a <code>TraversableOnce</code> of tasks, transforms it to a task signaling
the collection, executing the tasks one by one and gathering their
results in the same collection.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>TraversableOnce</code> of tasks, transforms it to a task signaling
the collection, executing the tasks one by one and gathering their
results in the same collection.</p><p>This operation will execute the tasks one by one, in order, which means that
both effects and results will be ordered. See <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">gather</a> and <a href="#gatherUnordered[A](in:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[List[A]]" class="extmbr" name="monix.eval.Task#gatherUnordered">gatherUnordered</a>
for unordered results or effects, and thus potential of running in parallel.</p><p> It's a simple version of <a href="#traverse[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B])(implicitcbf:scala.collection.generic.CanBuildFrom[M[A],B,M[B]]):monix.eval.Task[M[B]]" class="extmbr" name="monix.eval.Task#traverse">traverse</a>.
</p></div></div>
    </li><li name="monix.eval.Task#shift" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shift(ec:scala.concurrent.ExecutionContext):monix.eval.Task[Unit]"></a><a id="shift(ExecutionContext):Task[Unit]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#shift(ec:scala.concurrent.ExecutionContext):monix.eval.Task[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shift</span><span class="params">(<span name="ec">ec: <a href="http://www.scala-lang.org/api/2.12.4/scala/concurrent/ExecutionContext.html#scala.concurrent.ExecutionContext" class="extype" name="scala.concurrent.ExecutionContext">ExecutionContext</a></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Asynchronous boundary described as an effectful <code>Task</code> that
can be used in <code>flatMap</code> chains to &quot;shift&quot; the continuation
of the run-loop to another call stack or thread, managed by
the given execution context.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous boundary described as an effectful <code>Task</code> that
can be used in <code>flatMap</code> chains to &quot;shift&quot; the continuation
of the run-loop to another call stack or thread, managed by
the given execution context.</p><p>This is the equivalent of <code>IO.shift</code>.</p><p>For example we can introduce an
        asynchronous boundary in the <code>flatMap</code> chain before a
        certain task, this being literally the implementation of
        <a href="Task.html#executeAsync:monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#executeAsync">executeAsync</a>:</p><pre>Task.shift.flatMap(_ <span class="kw">=&gt;</span> task)</pre><p>        And this can also be described with <code>followedBy</code> from Cats:</p><pre><span class="kw">import</span> cats.syntax.all._

Task.shift.followedBy(task)</pre><p>        Or we can specify an asynchronous boundary <i>after</i>
        the evaluation of a certain task, this being literally
        the implementation of
        <a href="Task.html#asyncBoundary:monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#asyncBoundary">.asyncBoundary</a>:</p><pre>task.flatMap(a <span class="kw">=&gt;</span> Task.shift.map(_ <span class="kw">=&gt;</span> a))</pre><p>        And again we can also describe this with <code>forEffect</code>
        from Cats:</p><pre>task.forEffect(Task.shift)</pre></div></div>
    </li><li name="monix.eval.Task#shift" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shift:monix.eval.Task[Unit]"></a><a id="shift:Task[Unit]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#shift:monix.eval.Task[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">shift</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Asynchronous boundary described as an effectful <code>Task</code> that
can be used in <code>flatMap</code> chains to &quot;shift&quot; the continuation
of the run-loop to another thread or call stack, managed by
the default <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous boundary described as an effectful <code>Task</code> that
can be used in <code>flatMap</code> chains to &quot;shift&quot; the continuation
of the run-loop to another thread or call stack, managed by
the default <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>.</p><p>This is the equivalent of <code>IO.shift</code>, except that Monix's <code>Task</code>
gets executed with an injected <code>Scheduler</code> in
<a href="Task.html#runAsync(implicits:monix.execution.Scheduler):monix.execution.CancelableFuture[A]" class="extmbr" name="monix.eval.Task#runAsync">.runAsync</a> and that's going to be
the <code>Scheduler</code> responsible for the &quot;shift&quot;.</p><p>For example we can introduce an
        asynchronous boundary in the <code>flatMap</code> chain before a
        certain task, this being literally the implementation of
        <a href="Task.html#executeAsync:monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#executeAsync">executeAsync</a>:</p><pre>Task.shift.flatMap(_ <span class="kw">=&gt;</span> task)</pre><p>        And this can also be described with <code>followedBy</code> from Cats:</p><pre><span class="kw">import</span> cats.syntax.all._

Task.shift.followedBy(task)</pre><p>        Or we can specify an asynchronous boundary <i>after</i>
        the evaluation of a certain task, this being literally
        the implementation of
        <a href="Task.html#asyncBoundary:monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#asyncBoundary">.asyncBoundary</a>:</p><pre>task.flatMap(a <span class="kw">=&gt;</span> Task.shift.map(_ <span class="kw">=&gt;</span> a))</pre><p>        And again we can also describe this with <code>forEffect</code>
        from Cats:</p><pre>task.forEffect(Task.shift)</pre></div></div>
    </li><li name="monix.eval.Task#sleep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sleep(timespan:scala.concurrent.duration.FiniteDuration):monix.eval.Task[Unit]"></a><a id="sleep(FiniteDuration):Task[Unit]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#sleep(timespan:scala.concurrent.duration.FiniteDuration):monix.eval.Task[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sleep</span><span class="params">(<span name="timespan">timespan: <a href="http://www.scala-lang.org/api/2.12.4/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</a></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a new <code>Task</code> that will sleep for the given duration,
emitting a tick when that time span is over.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <code>Task</code> that will sleep for the given duration,
emitting a tick when that time span is over.</p><p>As an example on evaluation this will print &quot;Hello!&quot; after
3 seconds:</p><pre><span class="kw">import</span> scala.concurrent.duration._

Task.sleep(<span class="num">3.</span>seconds).flatMap { _ <span class="kw">=&gt;</span>
  Task.eval(println(<span class="lit">"Hello!"</span>))
}</pre><p>See <a href="Task.html#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#delayExecution">Task.delayExecution</a> for this operation described as
a method on <code>Task</code> references or <a href="Task.html#delayResult(timespan:scala.concurrent.duration.FiniteDuration):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#delayResult">Task.delayResult</a> for the
helper that triggers the evaluation of the source on time, but
then delays the result.
</p></div></div>
    </li><li name="monix.eval.Task#suspend" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="suspend[A](fa:=&gt;monix.eval.Task[A]):monix.eval.Task[A]"></a><a id="suspend[A](⇒Task[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#suspend[A](fa:=&gt;monix.eval.Task[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">suspend</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="fa">fa: ⇒ <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.suspend.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.suspend.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Alias for <a href="#defer[A](fa:=&gt;monix.eval.Task[A]):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#defer">defer</a>.</p>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="monix.eval.Task#tailRecM" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tailRecM[A,B](a:A)(f:A=&gt;monix.eval.Task[Either[A,B]]):monix.eval.Task[B]"></a><a id="tailRecM[A,B](A)((A)⇒Task[Either[A,B]]):Task[B]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#tailRecM[A,B](a:A)(f:A=&gt;monix.eval.Task[Either[A,B]]):monix.eval.Task[B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tailRecM</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="a">a: <span class="extype" name="monix.eval.Task.tailRecM.A">A</span></span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.tailRecM.A">A</span>) ⇒ <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="scala.Either">Either</span>[<span class="extype" name="monix.eval.Task.tailRecM.A">A</span>, <span class="extype" name="monix.eval.Task.tailRecM.B">B</span>]]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.tailRecM.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Keeps calling <code>f</code> until it returns a <code>Right</code> result.</p><div class="fullcomment"><div class="comment cmt"><p>Keeps calling <code>f</code> until it returns a <code>Right</code> result.</p><p>Based on Phil Freeman's
<a href="http://functorial.com/stack-safety-for-free/index.pdf" target="_blank">Stack Safety for Free</a>.
</p></div></div>
    </li><li name="monix.eval.TaskTimers#timer" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timer(s:monix.execution.Scheduler):cats.effect.Timer[monix.eval.Task]"></a><a id="timer(Scheduler):Timer[Task]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#timer(s:monix.execution.Scheduler):cats.effect.Timer[monix.eval.Task]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timer</span><span class="params">(<span name="s">s: <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a></span>)</span><span class="result">: <span class="extype" name="cats.effect.Timer">Timer</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a <code>cats.effect.Timer</code> instance, given a
<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a> reference.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <code>cats.effect.Timer</code> instance, given a
<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a> reference.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskTimers</dd></dl></div>
    </li><li name="monix.eval.TaskTimers#timer" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timer:cats.effect.Timer[monix.eval.Task]"></a><a id="timer:Timer[Task]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#timer:cats.effect.Timer[monix.eval.Task]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">timer</span><span class="result">: <span class="extype" name="cats.effect.Timer">Timer</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Default, pure, globally visible <code>cats.effect.Timer</code>
implementation that defers the evaluation to <code>Task</code>'s default
<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>
(that's being injected in <a href="Task.html#runAsync(implicits:monix.execution.Scheduler):monix.execution.CancelableFuture[A]" class="extmbr" name="monix.eval.Task#runAsync">runAsync</a>)
</p><div class="fullcomment"><div class="comment cmt"><p>Default, pure, globally visible <code>cats.effect.Timer</code>
implementation that defers the evaluation to <code>Task</code>'s default
<a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>
(that's being injected in <a href="Task.html#runAsync(implicits:monix.execution.Scheduler):monix.execution.CancelableFuture[A]" class="extmbr" name="monix.eval.Task#runAsync">runAsync</a>)
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskTimers</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="monix.eval.Task#traverse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="traverse[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B])(implicitcbf:scala.collection.generic.CanBuildFrom[M[A],B,M[B]]):monix.eval.Task[M[B]]"></a><a id="traverse[A,B,M[X]&lt;:TraversableOnce[X]](M[A])((A)⇒Task[B])(CanBuildFrom[M[A],B,M[B]]):Task[M[B]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#traverse[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B])(implicitcbf:scala.collection.generic.CanBuildFrom[M[A],B,M[B]]):monix.eval.Task[M[B]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">traverse</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="M">M<span class="tparams">[<span name="X">X</span>]</span> &lt;: <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<span class="extype" name="monix.eval.Task.traverse.M.X">X</span>]</span>]</span><span class="params">(<span name="in">in: <span class="extype" name="monix.eval.Task.traverse.M">M</span>[<span class="extype" name="monix.eval.Task.traverse.A">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.traverse.A">A</span>) ⇒ <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.traverse.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cbf">cbf: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/generic/CanBuildFrom.html#scala.collection.generic.CanBuildFrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<span class="extype" name="monix.eval.Task.traverse.M">M</span>[<span class="extype" name="monix.eval.Task.traverse.A">A</span>], <span class="extype" name="monix.eval.Task.traverse.B">B</span>, <span class="extype" name="monix.eval.Task.traverse.M">M</span>[<span class="extype" name="monix.eval.Task.traverse.B">B</span>]]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.traverse.M">M</span>[<span class="extype" name="monix.eval.Task.traverse.B">B</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given a <code>TraversableOnce[A]</code> and a function <code>A =&gt; Task[B]</code>, sequentially
apply the function to each element of the collection and gather their
results in the same collection.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>TraversableOnce[A]</code> and a function <code>A =&gt; Task[B]</code>, sequentially
apply the function to each element of the collection and gather their
results in the same collection.</p><p> It's a generalized version of <a href="#sequence[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#sequence">sequence</a>.
</p></div></div>
    </li><li name="monix.eval.Task#unit" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="unit:monix.eval.Task[Unit]"></a><a id="unit:Task[Unit]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#unit:monix.eval.Task[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">unit</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a>]</span>
      </span>
      
      <p class="shortcomment cmt">A <code>Task[Unit]</code> provided for convenience.</p>
    </li><li name="monix.eval.Task#unsafeCreate" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsafeCreate[A](register:(monix.eval.Task.Context,monix.eval.Callback[A])=&gt;Unit):monix.eval.Task[A]"></a><a id="unsafeCreate[A]((Context,Callback[A])⇒Unit):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#unsafeCreate[A](register:(monix.eval.Task.Context,monix.eval.Callback[A])=&gt;Unit):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsafeCreate</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="register">register: (<a href="Task$$Context.html" class="extype" name="monix.eval.Task.Context">Context</a>, <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>[<span class="extype" name="monix.eval.Task.unsafeCreate.A">A</span>]) ⇒ <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.unsafeCreate.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Constructs a lazy <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instance whose result
will be computed asynchronously.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a lazy <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instance whose result
will be computed asynchronously.</p><p>**WARNING:** Unsafe to use directly, only use if you know
what you're doing. For building <code>Task</code> instances safely
see <a href="#create[A](register:(monix.execution.Scheduler,monix.eval.Callback[A])=&gt;monix.execution.Cancelable):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#create">Task.create</a>.</p><p>Rules of usage:</p><ul><li>the received <code>StackedCancelable</code> can be used to store
   cancelable references that will be executed upon cancel;
   every <code>push</code> must happen at the beginning, before any
   execution happens and <code>pop</code> must happen afterwards
   when the processing is finished, before signaling the
   result</li><li>the received <code>FrameRef</code> indicates the current frame
   index and must be reset on real asynchronous boundaries
   (which avoids doing extra async boundaries in batched
   execution mode)</li><li>before execution, an asynchronous boundary is recommended,
   to avoid stack overflow errors, but can happen using the
   scheduler's facilities for trampolined execution</li><li>on signaling the result (<code>onSuccess</code>, <code>onError</code>),
   another async boundary is necessary, but can also
   happen with the scheduler's facilities for trampolined
   execution (e.g. <code>asyncOnSuccess</code> and <code>asyncOnError</code>)</li></ul><p>**WARNING:** note that not only is this builder unsafe, but also
unstable, as the callback type is exposing volatile internal
implementation details. This builder is meant to create
optimized asynchronous tasks, but for normal usage prefer
<a href="#create[A](register:(monix.execution.Scheduler,monix.eval.Callback[A])=&gt;monix.execution.Cancelable):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#create">Task.create</a>.
</p></div></div>
    </li><li name="monix.eval.Task#unsafeStartAsync" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsafeStartAsync[A](source:monix.eval.Task[A],context:monix.eval.Task.Context,cb:monix.eval.Callback[A]):Unit"></a><a id="unsafeStartAsync[A](Task[A],Context,Callback[A]):Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#unsafeStartAsync[A](source:monix.eval.Task[A],context:monix.eval.Task.Context,cb:monix.eval.Callback[A]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsafeStartAsync</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="source">source: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.unsafeStartAsync.A">A</span>]</span>, <span name="context">context: <a href="Task$$Context.html" class="extype" name="monix.eval.Task.Context">Context</a></span>, <span name="cb">cb: <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>[<span class="extype" name="monix.eval.Task.unsafeStartAsync.A">A</span>]</span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <p class="shortcomment cmt">Unsafe utility - starts the execution of a Task with a guaranteed
asynchronous boundary, by providing
the needed <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>,
<a href="../execution/cancelables/StackedCancelable.html" class="extype" name="monix.execution.cancelables.StackedCancelable">StackedCancelable</a>
and <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Unsafe utility - starts the execution of a Task with a guaranteed
asynchronous boundary, by providing
the needed <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>,
<a href="../execution/cancelables/StackedCancelable.html" class="extype" name="monix.execution.cancelables.StackedCancelable">StackedCancelable</a>
and <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>.</p><p>DO NOT use directly, as it is UNSAFE to use, unless you know
what you're doing. Prefer <a href="Task.html#runAsync(cb:monix.eval.Callback[A])(implicits:monix.execution.Scheduler):monix.execution.Cancelable" class="extmbr" name="monix.eval.Task#runAsync">Task.runAsync</a>
and <a href="Task.html#executeAsync:monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#executeAsync">.executeAsync</a>.
</p></div></div>
    </li><li name="monix.eval.Task#unsafeStartNow" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsafeStartNow[A](source:monix.eval.Task[A],context:monix.eval.Task.Context,cb:monix.eval.Callback[A]):Unit"></a><a id="unsafeStartNow[A](Task[A],Context,Callback[A]):Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#unsafeStartNow[A](source:monix.eval.Task[A],context:monix.eval.Task.Context,cb:monix.eval.Callback[A]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsafeStartNow</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="source">source: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.unsafeStartNow.A">A</span>]</span>, <span name="context">context: <a href="Task$$Context.html" class="extype" name="monix.eval.Task.Context">Context</a></span>, <span name="cb">cb: <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>[<span class="extype" name="monix.eval.Task.unsafeStartNow.A">A</span>]</span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <p class="shortcomment cmt">Unsafe utility - starts the execution of a Task, by providing
the needed <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>,
<a href="../execution/cancelables/StackedCancelable.html" class="extype" name="monix.execution.cancelables.StackedCancelable">StackedCancelable</a>
and <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Unsafe utility - starts the execution of a Task, by providing
the needed <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>,
<a href="../execution/cancelables/StackedCancelable.html" class="extype" name="monix.execution.cancelables.StackedCancelable">StackedCancelable</a>
and <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>.</p><p>DO NOT use directly, as it is UNSAFE to use, unless you know
what you're doing. Prefer <a href="Task.html#runAsync(cb:monix.eval.Callback[A])(implicits:monix.execution.Scheduler):monix.execution.Cancelable" class="extmbr" name="monix.eval.Task#runAsync">Task.runAsync</a>.
</p></div></div>
    </li><li name="monix.eval.Task#unsafeStartTrampolined" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsafeStartTrampolined[A](source:monix.eval.Task[A],context:monix.eval.Task.Context,cb:monix.eval.Callback[A]):Unit"></a><a id="unsafeStartTrampolined[A](Task[A],Context,Callback[A]):Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#unsafeStartTrampolined[A](source:monix.eval.Task[A],context:monix.eval.Task.Context,cb:monix.eval.Callback[A]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsafeStartTrampolined</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="source">source: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.unsafeStartTrampolined.A">A</span>]</span>, <span name="context">context: <a href="Task$$Context.html" class="extype" name="monix.eval.Task.Context">Context</a></span>, <span name="cb">cb: <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>[<span class="extype" name="monix.eval.Task.unsafeStartTrampolined.A">A</span>]</span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <p class="shortcomment cmt">Unsafe utility - starts the execution of a Task with a guaranteed
<a href="../execution/schedulers/TrampolinedRunnable.html" class="extype" name="monix.execution.schedulers.TrampolinedRunnable">trampolined asynchronous boundary</a>,
by providing the needed <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>,
<a href="../execution/cancelables/StackedCancelable.html" class="extype" name="monix.execution.cancelables.StackedCancelable">StackedCancelable</a>
and <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Unsafe utility - starts the execution of a Task with a guaranteed
<a href="../execution/schedulers/TrampolinedRunnable.html" class="extype" name="monix.execution.schedulers.TrampolinedRunnable">trampolined asynchronous boundary</a>,
by providing the needed <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a>,
<a href="../execution/cancelables/StackedCancelable.html" class="extype" name="monix.execution.cancelables.StackedCancelable">StackedCancelable</a>
and <a href="Callback.html" class="extype" name="monix.eval.Callback">Callback</a>.</p><p>DO NOT use directly, as it is UNSAFE to use, unless you know
what you're doing. Prefer <a href="Task.html#runAsync(cb:monix.eval.Callback[A])(implicits:monix.execution.Scheduler):monix.execution.Cancelable" class="extmbr" name="monix.eval.Task#runAsync">Task.runAsync</a>
and <a href="Task.html#executeAsync:monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#executeAsync">.executeAsync</a>.
</p></div></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/Long.html#scala.Long" class="extype" name="scala.Long">Long</a></span>, <span name="arg1">arg1: <a href="http://www.scala-lang.org/api/2.12.4/scala/Int.html#scala.Int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="http://www.scala-lang.org/api/2.12.4/scala/Long.html#scala.Long" class="extype" name="scala.Long">Long</a></span>)</span><span class="result">: <a href="http://www.scala-lang.org/api/2.12.4/scala/Unit.html#scala.Unit" class="extype" name="scala.Unit">Unit</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="monix.eval.Task#wander" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wander[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B])(implicitcbf:scala.collection.generic.CanBuildFrom[M[A],B,M[B]]):monix.eval.Task[M[B]]"></a><a id="wander[A,B,M[X]&lt;:TraversableOnce[X]](M[A])((A)⇒Task[B])(CanBuildFrom[M[A],B,M[B]]):Task[M[B]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#wander[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B])(implicitcbf:scala.collection.generic.CanBuildFrom[M[A],B,M[B]]):monix.eval.Task[M[B]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wander</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="M">M<span class="tparams">[<span name="X">X</span>]</span> &lt;: <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<span class="extype" name="monix.eval.Task.wander.M.X">X</span>]</span>]</span><span class="params">(<span name="in">in: <span class="extype" name="monix.eval.Task.wander.M">M</span>[<span class="extype" name="monix.eval.Task.wander.A">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.wander.A">A</span>) ⇒ <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.wander.B">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cbf">cbf: <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/generic/CanBuildFrom.html#scala.collection.generic.CanBuildFrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<span class="extype" name="monix.eval.Task.wander.M">M</span>[<span class="extype" name="monix.eval.Task.wander.A">A</span>], <span class="extype" name="monix.eval.Task.wander.B">B</span>, <span class="extype" name="monix.eval.Task.wander.M">M</span>[<span class="extype" name="monix.eval.Task.wander.B">B</span>]]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.wander.M">M</span>[<span class="extype" name="monix.eval.Task.wander.B">B</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given a <code>TraversableOnce[A]</code> and a function <code>A =&gt; Task[B]</code>,
nondeterministically apply the function to each element of the collection
and return a task that will signal a collection of the results once all
tasks are finished.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>TraversableOnce[A]</code> and a function <code>A =&gt; Task[B]</code>,
nondeterministically apply the function to each element of the collection
and return a task that will signal a collection of the results once all
tasks are finished.</p><p>This function is the nondeterministic analogue of <code>traverse</code> and should
behave identically to <code>traverse</code> so long as there is no interaction between
the effects being gathered. However, unlike <code>traverse</code>, which decides on
a total order of effects, the effects in a <code>wander</code> are unordered with
respect to each other.</p><p>Although the effects are unordered, we ensure the order of results
matches the order of the input sequence. Also see <a href="#wanderUnordered[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B]):monix.eval.Task[List[B]]" class="extmbr" name="monix.eval.Task#wanderUnordered">wanderUnordered</a>
for the more efficient alternative.</p><p>It's a generalized version of <a href="#gather[A,M[X]&lt;:TraversableOnce[X]](in:M[monix.eval.Task[A]])(implicitcbf:scala.collection.generic.CanBuildFrom[M[monix.eval.Task[A]],A,M[A]]):monix.eval.Task[M[A]]" class="extmbr" name="monix.eval.Task#gather">gather</a>.
</p></div></div>
    </li><li name="monix.eval.Task#wanderUnordered" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wanderUnordered[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B]):monix.eval.Task[List[B]]"></a><a id="wanderUnordered[A,B,M[X]&lt;:TraversableOnce[X]](M[A])((A)⇒Task[B]):Task[List[B]]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#wanderUnordered[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B]):monix.eval.Task[List[B]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wanderUnordered</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="M">M<span class="tparams">[<span name="X">X</span>]</span> &lt;: <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<span class="extype" name="monix.eval.Task.wanderUnordered.M.X">X</span>]</span>]</span><span class="params">(<span name="in">in: <span class="extype" name="monix.eval.Task.wanderUnordered.M">M</span>[<span class="extype" name="monix.eval.Task.wanderUnordered.A">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="monix.eval.Task.wanderUnordered.A">A</span>) ⇒ <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.wanderUnordered.B">B</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="monix.eval.Task.wanderUnordered.B">B</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Given a <code>TraversableOnce[A]</code> and a function <code>A =&gt; Task[B]</code>,
nondeterministically apply the function to each element of the collection
without keeping the original ordering of the results.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>TraversableOnce[A]</code> and a function <code>A =&gt; Task[B]</code>,
nondeterministically apply the function to each element of the collection
without keeping the original ordering of the results.</p><p>This function is similar to <a href="#wander[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B])(implicitcbf:scala.collection.generic.CanBuildFrom[M[A],B,M[B]]):monix.eval.Task[M[B]]" class="extmbr" name="monix.eval.Task#wander">wander</a>, but neither the effects nor the
results will be ordered. Useful when you don't need ordering because:</p><ul><li>it has non-blocking behavior (but not wait-free)</li><li>it can be more efficient (compared with <a href="#wander[A,B,M[X]&lt;:TraversableOnce[X]](in:M[A])(f:A=&gt;monix.eval.Task[B])(implicitcbf:scala.collection.generic.CanBuildFrom[M[A],B,M[B]]):monix.eval.Task[M[B]]" class="extmbr" name="monix.eval.Task#wander">wander</a>), but not
   necessarily (if you care about performance, then test)</li></ul><p>It's a generalized version of <a href="#gatherUnordered[A](in:TraversableOnce[monix.eval.Task[A]]):monix.eval.Task[List[A]]" class="extmbr" name="monix.eval.Task#gatherUnordered">gatherUnordered</a>.
</p></div></div>
    </li><li name="monix.eval.Task#zip2" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="zip2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2]):monix.eval.Task[(A1,A2)]"></a><a id="zip2[A1,A2,R](Task[A1],Task[A2]):Task[(A1,A2)]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#zip2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2]):monix.eval.Task[(A1,A2)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip2</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip2.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip2.A2">A2</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[(<span class="extype" name="monix.eval.Task.zip2.A1">A1</span>, <span class="extype" name="monix.eval.Task.zip2.A2">A2</span>)]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs two <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instances using <a href="#parMap2[A1,A2,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2])(f:(A1,A2)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap2">parMap2</a>.</p>
    </li><li name="monix.eval.Task#zip3" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="zip3[A1,A2,A3](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3]):monix.eval.Task[(A1,A2,A3)]"></a><a id="zip3[A1,A2,A3](Task[A1],Task[A2],Task[A3]):Task[(A1,A2,A3)]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#zip3[A1,A2,A3](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3]):monix.eval.Task[(A1,A2,A3)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip3</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip3.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip3.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip3.A3">A3</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[(<span class="extype" name="monix.eval.Task.zip3.A1">A1</span>, <span class="extype" name="monix.eval.Task.zip3.A2">A2</span>, <span class="extype" name="monix.eval.Task.zip3.A3">A3</span>)]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs three <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instances using <a href="#parMap3[A1,A2,A3,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3])(f:(A1,A2,A3)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap3">parMap3</a>.</p>
    </li><li name="monix.eval.Task#zip4" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="zip4[A1,A2,A3,A4](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4]):monix.eval.Task[(A1,A2,A3,A4)]"></a><a id="zip4[A1,A2,A3,A4](Task[A1],Task[A2],Task[A3],Task[A4]):Task[(A1,A2,A3,A4)]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#zip4[A1,A2,A3,A4](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4]):monix.eval.Task[(A1,A2,A3,A4)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip4</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip4.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip4.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip4.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip4.A4">A4</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[(<span class="extype" name="monix.eval.Task.zip4.A1">A1</span>, <span class="extype" name="monix.eval.Task.zip4.A2">A2</span>, <span class="extype" name="monix.eval.Task.zip4.A3">A3</span>, <span class="extype" name="monix.eval.Task.zip4.A4">A4</span>)]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs four <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instances using <a href="#parMap4[A1,A2,A3,A4,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4])(f:(A1,A2,A3,A4)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap4">parMap4</a>.</p>
    </li><li name="monix.eval.Task#zip5" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="zip5[A1,A2,A3,A4,A5](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5]):monix.eval.Task[(A1,A2,A3,A4,A5)]"></a><a id="zip5[A1,A2,A3,A4,A5](Task[A1],Task[A2],Task[A3],Task[A4],Task[A5]):Task[(A1,A2,A3,A4,A5)]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#zip5[A1,A2,A3,A4,A5](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5]):monix.eval.Task[(A1,A2,A3,A4,A5)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip5</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip5.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip5.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip5.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip5.A4">A4</span>]</span>, <span name="fa5">fa5: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip5.A5">A5</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[(<span class="extype" name="monix.eval.Task.zip5.A1">A1</span>, <span class="extype" name="monix.eval.Task.zip5.A2">A2</span>, <span class="extype" name="monix.eval.Task.zip5.A3">A3</span>, <span class="extype" name="monix.eval.Task.zip5.A4">A4</span>, <span class="extype" name="monix.eval.Task.zip5.A5">A5</span>)]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs five <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instances using <a href="#parMap5[A1,A2,A3,A4,A5,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap5">parMap5</a>.</p>
    </li><li name="monix.eval.Task#zip6" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="zip6[A1,A2,A3,A4,A5,A6](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6]):monix.eval.Task[(A1,A2,A3,A4,A5,A6)]"></a><a id="zip6[A1,A2,A3,A4,A5,A6](Task[A1],Task[A2],Task[A3],Task[A4],Task[A5],Task[A6]):Task[(A1,A2,A3,A4,A5,A6)]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#zip6[A1,A2,A3,A4,A5,A6](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6]):monix.eval.Task[(A1,A2,A3,A4,A5,A6)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip6</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="A6">A6</span>]</span><span class="params">(<span name="fa1">fa1: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip6.A1">A1</span>]</span>, <span name="fa2">fa2: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip6.A2">A2</span>]</span>, <span name="fa3">fa3: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip6.A3">A3</span>]</span>, <span name="fa4">fa4: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip6.A4">A4</span>]</span>, <span name="fa5">fa5: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip6.A5">A5</span>]</span>, <span name="fa6">fa6: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.zip6.A6">A6</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[(<span class="extype" name="monix.eval.Task.zip6.A1">A1</span>, <span class="extype" name="monix.eval.Task.zip6.A2">A2</span>, <span class="extype" name="monix.eval.Task.zip6.A3">A3</span>, <span class="extype" name="monix.eval.Task.zip6.A4">A4</span>, <span class="extype" name="monix.eval.Task.zip6.A5">A5</span>, <span class="extype" name="monix.eval.Task.zip6.A6">A6</span>)]</span>
      </span>
      
      <p class="shortcomment cmt">Pairs six <a href="Task.html" class="extype" name="monix.eval.Task">Task</a> instances using <a href="#parMap6[A1,A2,A3,A4,A5,A6,R](fa1:monix.eval.Task[A1],fa2:monix.eval.Task[A2],fa3:monix.eval.Task[A3],fa4:monix.eval.Task[A4],fa5:monix.eval.Task[A5],fa6:monix.eval.Task[A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.eval.Task[R]" class="extmbr" name="monix.eval.Task#parMap6">parMap6</a>.</p>
    </li><li name="monix.eval.Task.Context" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Context"></a><a id="Context:Context"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#Context" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Task$$Context$.html"><span class="name">Context</span></a><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      
      
    </li><li name="monix.eval.Task.FrameIndexRef" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="FrameIndexRef"></a><a id="FrameIndexRef:FrameIndexRef"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#FrameIndexRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Task$$FrameIndexRef$.html"><span class="name">FrameIndexRef</span></a>
      </span>
      
      
    </li><li name="monix.eval.TaskParallelNewtype.Par" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Par"></a><a id="Par:Par"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#Par" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">Par</span><span class="result"> extends <span class="extype" name="monix.execution.internal.Newtype1">Newtype1</span>[<a href="Task.html" class="extype" name="monix.eval.Task">Task</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Newtype encoding, see the <a href="#Par[+A]=TaskParallelNewtype.this.Par.Type[A]" class="extmbr" name="monix.eval.Task.Par">Task.Par</a> type alias
for more details.</p><div class="fullcomment"><div class="comment cmt"><p>Newtype encoding, see the <a href="#Par[+A]=TaskParallelNewtype.this.Par.Type[A]" class="extmbr" name="monix.eval.Task.Par">Task.Par</a> type alias
for more details.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>TaskParallelNewtype</dd></dl></div>
    </li>
              </ol>
            </div>

        

        <div class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="monix.eval.Task#fork" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fork[A](fa:monix.eval.Task[A],s:monix.execution.Scheduler):monix.eval.Task[A]"></a><a id="fork[A](Task[A],Scheduler):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#fork[A](fa:monix.eval.Task[A],s:monix.execution.Scheduler):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 3.0.0) Please use Task!.executeOn">fork</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="fa">fa: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fork.A">A</span>]</span>, <span name="s">s: <a href="../execution/Scheduler.html" class="extype" name="monix.execution.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fork.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">DEPRECATED — please use <a href="Task.html#executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#executeOn">.executeOn</a>.</p><div class="fullcomment"><div class="comment cmt"><p>DEPRECATED — please use <a href="Task.html#executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#executeOn">.executeOn</a>.</p><p>The reason for the deprecation is the repurposing of the word &quot;fork&quot;.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.0.0)</i> Please use Task!.executeOn</p></dd></dl></div>
    </li><li name="monix.eval.Task#fork" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fork[A](fa:monix.eval.Task[A]):monix.eval.Task[A]"></a><a id="fork[A](Task[A]):Task[A]"></a>
      <span class="permalink">
      <a href="../../monix/eval/Task$.html#fork[A](fa:monix.eval.Task[A]):monix.eval.Task[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 3.0.0) Please use Task!.executeAsync">fork</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="fa">fa: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fork.A">A</span>]</span>)</span><span class="result">: <a href="Task.html" class="extype" name="monix.eval.Task">Task</a>[<span class="extype" name="monix.eval.Task.fork.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">DEPRECATED — please use <a href="Task.html#executeAsync:monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#executeAsync">.executeAsync</a>.</p><div class="fullcomment"><div class="comment cmt"><p>DEPRECATED — please use <a href="Task.html#executeAsync:monix.eval.Task[A]" class="extmbr" name="monix.eval.Task#executeAsync">.executeAsync</a>.</p><p>The reason for the deprecation is the repurposing of the word &quot;fork&quot;.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.0.0)</i> Please use Task!.executeAsync</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.Serializable">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.4/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></h3>
            </div><div class="parent" name="java.io.Serializable">
              <h3>Inherited from <span class="extype" name="java.io.Serializable">Serializable</span></h3>
            </div><div class="parent" name="monix.eval.TaskInstancesLevel1">
              <h3>Inherited from <span class="extype" name="monix.eval.TaskInstancesLevel1">TaskInstancesLevel1</span></h3>
            </div><div class="parent" name="monix.eval.TaskInstancesLevel0">
              <h3>Inherited from <span class="extype" name="monix.eval.TaskInstancesLevel0">TaskInstancesLevel0</span></h3>
            </div><div class="parent" name="monix.eval.TaskParallelNewtype">
              <h3>Inherited from <span class="extype" name="monix.eval.TaskParallelNewtype">TaskParallelNewtype</span></h3>
            </div><div class="parent" name="monix.eval.TaskTimers">
              <h3>Inherited from <span class="extype" name="monix.eval.TaskTimers">TaskTimers</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.AnyRef" class="extype" name="scala.collection.immutable.List">AnyRef</a></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.4/scala/collection/immutable/List.html#scala.Any" class="extype" name="scala.collection.immutable.List">Any</a></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
